<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="# LLVM  &#96;LLVM&#96; 是 &#96;Low Level Virtual Machine&#96; （低级虚拟机）的首字母缩写， &#96;LLVM&#96; 发展至今已不再是“低级”虚拟机了，而是一个编译器的基础设施系统框架，提供程序分析、代码优化、机器代码生成等功能。  ## LLVM 工具链  &#96;LLVM&#96; 有专门的文件格式 &#96;.ll&#96;（可读的 &#96;LLVM&#96; 字节码文件）、 &#96;.bc&#96;（可读的 &#96;LLVM&#96; 字节码">
<meta property="og:type" content="article">
<meta property="og:title" content="Clang教程">
<meta property="og:url" content="http://yoursite.com/2020/07/19/Clang%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="李太吉的技术博客">
<meta property="og:description" content="# LLVM  &#96;LLVM&#96; 是 &#96;Low Level Virtual Machine&#96; （低级虚拟机）的首字母缩写， &#96;LLVM&#96; 发展至今已不再是“低级”虚拟机了，而是一个编译器的基础设施系统框架，提供程序分析、代码优化、机器代码生成等功能。  ## LLVM 工具链  &#96;LLVM&#96; 有专门的文件格式 &#96;.ll&#96;（可读的 &#96;LLVM&#96; 字节码文件）、 &#96;.bc&#96;（可读的 &#96;LLVM&#96; 字节码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/07/19/Clang%E6%95%99%E7%A8%8B/fib.jpg">
<meta property="og:image" content="http://yoursite.com/2020/07/19/Clang%E6%95%99%E7%A8%8B/check.jpg">
<meta property="og:image" content="http://yoursite.com/2020/07/19/Clang%E6%95%99%E7%A8%8B/ssa.jpg">
<meta property="og:image" content="http://yoursite.com/2020/07/19/Clang%E6%95%99%E7%A8%8B/ssacontrol.jpg">
<meta property="og:image" content="http://yoursite.com/2020/07/19/Clang%E6%95%99%E7%A8%8B/merge.jpg">
<meta property="og:image" content="http://yoursite.com/2020/07/19/Clang%E6%95%99%E7%A8%8B/implement.jpg">
<meta property="og:image" content="http://yoursite.com/2020/07/19/Clang%E6%95%99%E7%A8%8B/cfg.png">
<meta property="article:published_time" content="2020-07-19T09:06:35.000Z">
<meta property="article:modified_time" content="2020-07-19T09:07:57.509Z">
<meta property="article:author" content="李太吉">
<meta property="article:tag" content="C&#x2F;C++ Java Rust">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/07/19/Clang%E6%95%99%E7%A8%8B/fib.jpg">

<link rel="canonical" href="http://yoursite.com/2020/07/19/Clang%E6%95%99%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Clang教程 | 李太吉的技术博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李太吉的技术博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">人生到处知何似 应似飞鸿踏雪泥</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/19/Clang%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李太吉">
      <meta itemprop="description" content="NPUer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李太吉的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Clang教程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-19 17:06:35 / 修改时间：17:07:57" itemprop="dateCreated datePublished" datetime="2020-07-19T17:06:35+08:00">2020-07-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        
# LLVM

`LLVM` 是 `Low Level Virtual Machine` （低级虚拟机）的首字母缩写， `LLVM` 发展至今已不再是“低级”虚拟机了，而是一个编译器的基础设施系统框架，提供程序分析、代码优化、机器代码生成等功能。

## LLVM 工具链

`LLVM` 有专门的文件格式 `.ll`（可读的 `LLVM` 字节码文件）、 `.bc`（可读的 `LLVM` 字节码文件），同时`LLVM` 也有其他的配套工具链用于编译、优化、链接等。`.bc` 文件比 `.ll` 文件多进行了汇编阶段，因此我们可以通过反汇编 `.bc` 文件得到 `.ll` 文件。下面我们已 `main.cpp` 和 `fib.cpp` 为例介绍 `LLVM` 工具链。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fib.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result = f0 + f1;</span><br><span class="line">        f0 = f1;</span><br><span class="line">        f1 = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please enter the order number: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The %dth Fibonacci number: %lld\n"</span>, n, fib(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



### llvm-as

将 `.ll ` 文件反汇编为 `bc ` 文件：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-as main.ll -o main.bc</span><br></pre></td></tr></table></figure>



### llvm-dis

将 `.bc` 文件反汇编为 `.ll ` 文件：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-dis main.bc -o main.ll</span><br></pre></td></tr></table></figure>



### llvm-link

传统的编译器一般是对 `obj` 文件进行链接，`LLVM` 也可以对 `.ll` 和 `.bc` 文件（以下统称 `LLVM` 字节码文件）进行链接。

`llvm-link` 接受 `.ll` 和 `.bc` 文件，进行链接并可输出 `.ll` 和 `.bc` 文件：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">llvm-link main.ll fib.ll -S -o linked.ll</span><br><span class="line">llvm-link main.bc fib.bc -o linked.bc</span><br></pre></td></tr></table></figure>



### lli

`LLVM` 可以直接运行 `.ll` 和 `.bc` 文件。

`lli` 执行 `.ll` 和 `.bc` 文件：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lli linked.ll</span><br><span class="line">lli linked.bc</span><br></pre></td></tr></table></figure>

**注：**`lli` 工具使用 `JIT` （即时编译）作为执行 `LLVM` 字节码文件的默认方法，若你的源码中包含对库函数或其他外部函数的调用，`lli` 运行时一般会出错。因为正常编译时，链接器会处理这些调用的外部函数，而 `LLVM` 字节码文件尚未经过链接，这些外部函数在 `LLVM` 字节码文件中只是一些符号，直接通过 `lli` 运行会出现未定义错误。



### llc

`LLVM` 可以将 `.ll` 和 `.bc` 文件编译为通用汇编语言。

`llc` 编译 `LLVM` 源文件到用于指定的体系结构的汇编语言：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc main.ll -o main.s</span><br></pre></td></tr></table></figure>



### opt

`LLVM` 还可以对 `.ll` 和 `.bc` 进行优化，`LLVM` 的优化能力也是`LLVM` 的一项突出能力。

**注：**

1. 当使用 `-O0` 编译（默认即是 `-O0` ）时，`Clang` 向每个函数添加 `optnone` 属性，这阻止了以后的进一步优化，为了防止这种情况，可以添加 `-Xclang -disable-O0-optnone` 选项。

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ fib.cpp -Xclang -disable-O0-optnone -emit-llvm -S -o fib.ll</span><br></pre></td></tr></table></figure>

2. 当希望进行调试时，最好使用 `-O0` 或 `-O1` 编译，因为优化可能会改变控制流，导致指令执行顺序发生变化；还可能直接将一些潜在的 `bug` 优化掉（尽管 `bug` 没有了，但这是编译器优化解决的，不代表代码正确，你甚至不知道 `bug` 的存在，当你更换编译选项或者编译器时，`bug` 就又出现了）。

3. 越高的优化级别生成的代码一般执行速度更快，但代码大小也普遍更大。

4. `clang` 是一个驱动程序，给 `clang` 传入优化选项实质是传给了 `opt` 。

`opt` 可以对 `.ll` 和 `.bc` 文件进行优化，`opt` 可以接受的优化选项很多，这里不再赘述。`opt` 还可以生成控制流图（`Control Flow Graphic` ）：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; clang++ fib.cpp -emit-llvm -fno-discard-value-names -S -o fib.ll</span><br><span class="line">&gt; opt -analyze -dot-cfg-only fib.ll</span><br><span class="line">Writing &#39;._Z3fibi.dot&#39;...</span><br><span class="line">Printing analysis &#39;Print CFG of function to &#39;dot&#39; file (with no function bodies)&#39; for function &#39;_Z3fibi&#39;:</span><br></pre></td></tr></table></figure>

你会得到一些 `.dot` 文件，你需要配置 `Graphviz` ，执行 `dot  ._Z3fibi.dot -Tpng -o fib.png` 。

<img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/fib.jpg" alt="cfg" style="zoom: 80%;">

`opt` 还支持以下的可视化图形帮助理解分析逻辑：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--view-callgraph                                  - View call graph</span><br><span class="line">--view-cfg                                        - View CFG of function</span><br><span class="line">--view-cfg-only                                   - View CFG of function (with no function bodies)</span><br><span class="line">--view-dom                                        - View dominance tree of function</span><br><span class="line">--view-dom-only                                   - View dominance tree of function (with no function bodies)</span><br><span class="line">--view-postdom                                    - View postdominance tree of function</span><br><span class="line">--view-postdom-only                               - View postdominance tree of function (with no function bodies)</span><br><span class="line">--view-regions                                    - View regions of function</span><br><span class="line">--view-regions-only                               - View regions of function (with no function bodies)</span><br></pre></td></tr></table></figure>

`opt` 可以根据硬件平台的不同执行不同的优化，可以参看[编译器优化做指令调度时是怎么考虑不同的微架构下对同一个指令的执行周期数是不同的？ - RednaxelaFX的回答 - 知乎]( https://www.zhihu.com/question/31379945/answer/51755394)以及使用[clang: how to list supported target architectures?](https://stackoverflow.com/questions/15036909/clang-how-to-list-supported-target-architectures)查看 `LLVM` 支持的平台和 `CPU` 。



### lld

`LLVM` 拥有配套的链接器 `LLD`，可以进行链接时优化（`Link Time Optimization` ），而且相对于 `GNU ld` ，链接速度更快，编译输出更小，具体请查看[ `LLD` 官网](http://lld.llvm.org/)。

可以在编译时添加 `-fuse-ld=lld` 选项来指定  `LLD` 链接器：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ main.cpp -fuse-ld&#x3D;lld -o main.exe</span><br></pre></td></tr></table></figure>

`LLVM` 通过 `LLVM IR` 来实现 `LTO`，如果想使用 `LTO` ，需要在编译每个待链接的文件以及链接这些文件时都添加 `-flto` 选项：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang++ main.cpp -flto -O1 -c -o main.o</span><br><span class="line">clang++ factorial.bc -flto -O1 -c -o factorial.o</span><br><span class="line">clang++ mian.o factorial.o -flto -fuse-ld&#x3D;lld -o main.exe</span><br></pre></td></tr></table></figure>

关于 `LTO` ，可以查看官网上 [`LLVM LTO` ](https://llvm.org/docs/LinkTimeOptimization.html) 的介绍，以及 `GCC `[ `LTO `](https://stackoverflow.com/questions/48030706/can-lto-for-gcc-or-clang-optimize-across-c-and-c-methods)的介绍。

**注意：**

1.  `Clang` 和 `GCC` 都支持 `LTO`，但由于 `LTO` 是通过中间表示（`GCC` 上为 `GIMPLE` ，`Clang`上为 `LLVM IR` ）实现的，所以不能 `Clang` 和 `GCC` 的 `LTO` 不通用。
2. 若要使用 `LTO` ，建议使用相同的选项编译参与链接的所有文件，且必须在编译和链接时添加选项 `-flto` 。但优化标志 `-Og` 、`-O2` 和 `-Os ` 可以作为优化属性传递，而不会受限于编译时和链接时间标志应该相同的情况。
3. 在链接时传递的优化和目标选项将被忽略。
4.  有时需要在编译 `.obj` 文件时添加 `-O1` 等优化选项，才会启用 `LTO` 。



### lldb

`LLVM` 也有对应的调试器 `LLDB`，`LLDB` 与 `GDB` 功能类似，但命令更加友好，而且`LLDB` 具有与 `Clang` 相同的有点，也就是它可以高亮显示调试和错误信息。可以登录[ `LLDB` 官网](https://lldb.llvm.org)，学习`LLDB`  的[教程](https://lldb.llvm.org/use/tutorial.html)，以及查看 `LLDB` 与 `GDB` 命令的[对照](https://lldb.llvm.org/use/map.html)，你也可以首先学习 `GDB` 的教程 [RMS's gdb Debugger Tutorial](http://www.unknownroad.com/rtfm/gdbtut/)。



## LLVM IR 文件的布局



### Target Information

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID &#x3D; &#39;main.cpp&#39;</span><br><span class="line">source_filename &#x3D; &quot;main.cpp&quot;</span><br><span class="line">target datalayout &#x3D; &quot;e-m:w-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple &#x3D; &quot;x86_64-w64-windows-gnu&quot;</span><br></pre></td></tr></table></figure>

`target datalayout` 为 `target` 的数据布局，`target triple` 为 `target` 的平台信息。

![target](target.jpg)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i64:64 &#x2F;&#x2F; 指定支持的整型的对齐单位，这里即是指支持64bit的整型，且以64bit对齐（存储整型的起始地址必须是128的倍数）</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f80:128 &#x2F;&#x2F; 指定支持的浮点类型的对齐单位，这里即是指支持80bit的浮点类型，但是以128bit对齐（存储浮点数的起始地址必须是128的倍数）</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n8:16:32:64 &#x2F;&#x2F; 指定一组支持的以位为单位的整数类型</span><br></pre></td></tr></table></figure>

其他具体信息，参看[datalayout](https://llvm.org/docs/LangRef.html#data-layout)。



我的`target triple` 为 `"x86_64-w64-windows-gnu"`，即 `Windows` `x64` 操作系统上以 `MinGW` 为运行时环境（一般 `Windows` 系统上以 `MSVC` 为运行时环境， `Windows` 系统和 `GCC` 搭配来使用 `LLVM` 较为麻烦，但我觉得 `MSVC` 实在是太臃肿了。不过电脑配置如果满足要求，还是建议在 `Windows` 系统上使用 `MSVC`，因为许多软件在 `Windows` 系统上支持甚至唯一支持 `MSVC` 。使用 `MSVC`不仅省去了不少麻烦，而且 `Windows` 开发人员早晚跳不过 `Visual Studio` 。）。

可以通过 `clang -v` 查看 `Clang` 的版本和 `target` 信息，例如我的`Clang`具体信息为

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clang version 9.0.0 (tags&#x2F;RELEASE_900&#x2F;final)</span><br><span class="line">Target: x86_64-w64-windows-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">InstalledDir: D:\LLVM\bin</span><br></pre></td></tr></table></figure>

`Clang` 编译时可以通过`--target` 选项指定编译的目标平台，从而实现交叉编译，当然你需要有对应的运行时库（也就是说，假如你在 `Linux` 平台上下载了 `MSVC` 的运行时库，你就可以在  `Linux` 平台上编译 `MSVC` 支持的程序）。还可以将不同语言编译到 `LLVM IR` 层面进行链接，实现多语言的相互调用。这是 `LLVM` 非常大的一个优势，借助于 `LLVM IR`，`LLVM` 实现了平台独立性和灵活性。

![crosscompile](crosscompile.jpg)

`Clang` 支持下列 `target triple `的组合，具体可以查看`Clang` 的[文档](http://clang.llvm.org/docs/CrossCompilation.html)：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The triple has the general format &lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;, where:</span><br><span class="line">arch &#x3D; x86, arm, thumb, mips, etc.</span><br><span class="line">sub &#x3D; for ex. on ARM: v5, v6m, v7a, v7m, etc.</span><br><span class="line">vendor &#x3D; pc, apple, nvidia, ibm, etc.</span><br><span class="line">sys &#x3D; none, linux, win32, darwin, cuda, etc.</span><br><span class="line">abi &#x3D; eabi, gnu, android, macho, elf, etc.</span><br></pre></td></tr></table></figure>

常用的 `target triple ` 有：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi</span><br><span class="line">armv7a-none-eabi</span><br><span class="line">arm-linux-gnueabihf </span><br><span class="line">arm-none-linux-gnueabi</span><br><span class="line">i386-pc-linux-gnu </span><br><span class="line">x86_64-apple-darwin10</span><br><span class="line">i686-w64-windows-gnu # same as i686-w64-mingw32</span><br><span class="line">x86_64-pc-linux-gnu # from ubuntu 64 bit</span><br><span class="line">x86_64-unknown-windows-cygnus # cygwin 64-bit</span><br><span class="line">x86_64-w64-windows-gnu # same as x86_64-w64-mingw32</span><br><span class="line">i686-pc-windows-gnu # MSVC</span><br><span class="line">x86_64-pc-windows-gnu # MSVC 64-BIT</span><br></pre></td></tr></table></figure>



### LLVM IR 文件的架构

![layout](layout.jpg)

`LLVM IR` 文件从高到低由 `Moudle` 、`Function` 、 `Basic Block` 和 `Instruction`四个层次组成。



## SSA （静态单分配）

### 定义

> `SSA` 形式是指程序中的每个变量必须且只能在定义时初始化。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 10;</span><br><span class="line">int y &#x3D; 20; &#x2F;&#x2F; SSA</span><br><span class="line"></span><br><span class="line">int x;</span><br><span class="line">x &#x3D; 10; &#x2F;&#x2F; Not SSA</span><br></pre></td></tr></table></figure>

编译器为了进行代码优化，会对变量的定义和使用进行分析，主要有两种：

- 使用-定义链（ `Use-­Definition (UD) Chains` )：

    > 对于给定的变量 `x` 的定义，它的所有使用是什么？

- 定义-使用链（ `­Definition-Use (UD) Chains` )：

    > 对于给定的变量 `x` 的使用，它的所有可达性定义是什么？

不幸的是，`UD` 和 `DU` 检查的花费可能会非常昂贵。

<img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/check.jpg" alt="check" style="zoom: 80%;">

这是由于 `x` 可以重复赋值（也即重定义）导致的，自然地，我们可以想到让每个变量只能定义一次（可以类比 `Java` 中的 `static final` 常量，但略有不同，`Java` 中的 `static final` 常量可以延迟赋值，把赋值语句放在 `static` 块中）。

<img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/ssa.jpg" alt="ssa" style="zoom:50%;">

但 `SSA` 在处理控制流分支时存在一个问题：

<img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/ssacontrol.jpg" alt="ssacontrol" style="zoom: 67%;">

变量每次赋值在 `SSA` 中都成为了一个新的变量，在线性运行时没有问题，但在遇到分支时就无法判断要使用那个新变量了。我们需要$\Phi$ 节点来实现控制流。

#### $\Phi$ 函数

> $\Phi$ 函数将各个控制流分支路径上的定义合并为一个单一的定义

<img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/merge.jpg" alt="merge" style="zoom: 67%;">

传统指令集并不支持 $\Phi$ 函数（即 `LLVM IR` 中的 `phi` 指令）的概念，`LLVM` 会对 `phi` 指令进行 `Phi destruction` ，将 `phi` 指令变为底层支持的汇编命令，例如我们可以通过在各个控制流分支路径上插入语句定义一个共享变量来实现 $\Phi$ 节点，也可以将因赋值而新定义的变量分配到同一个寄存器，从而实现在 `LLVM IR` 层次上保持 `SSA` 形式，而在寄存器层次上实质为同一变量。可以阅读[llvm的reg2mem pass做了哪些事情？ - 蓝色的回答 - 知乎](https://www.zhihu.com/question/49642237/answer/117428698)。



<img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/implement.jpg" alt="implement" style="zoom: 67%;">

**初级 SSA**

- 每个赋值都会生成一个新的变量。

- 在每个插入点为所有分支中的新变量插入 $\Phi$ 节点。

**最小化 SSA**

- 每个赋值都会生成一个新的变量。

- 在每个插入点为处于活跃期的分支中的新变量插入 $\Phi$ 节点。活跃期定义是从变量第一次被定义（赋值）开始，到它下一次被赋值前的最后一次被使用为止。

##### 什么时候插入 $\Phi$ 函数

对于变量 `x` ，我们当且仅当以下情况时在 `Z` 中插入 $\Phi$ 函数：

<img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/cfg.png" alt="cfg" style="zoom: 67%;">

- 变量 `x` 在各个分支（ `if.then`、 `if.else`）总共定义了多于一次。

- 变量 `x` 新定义所在的块都可以到达块 `Z` ，且块 `Z` 是变量 `x` 新定义所在块的最先公共后继。

可以应用 [ `Lengauer-Tarjan` ](http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s14/public/lectures/L13-SSA-Concepts-1up.pdf)算法计算支配树和支配边界判断插入 $\Phi$ 函数的块，关于支配树和支配边界还可以阅读[构造Dominator Tree以及Dominator Frontier](https://blog.csdn.net/dashuniuniu/article/details/52224882)。


### SSA 在编译优化中的作用

- 常量传播（ `constant propagation` ）

    > 当 v $\leftarrow$ c 或 v $\leftarrow$ $\Phi$ (c, c, c) 时将  `v` 替换为 `c` ，并将 v $\leftarrow$  c 和 v $\leftarrow$ $\Phi$ (c, c, c) 语句删除。

- 复写传播（ `copy propagation` ）

    > 当 x $\leftarrow$ y 或 x $\leftarrow$ $\Phi$ (y, y, y) 时将  `x` 替换为 `y` ，并将 x $\leftarrow$ y 和 x $\leftarrow$ $\Phi$ (y, y, y) 语句删除。

- 常量折叠（ `constant folding` ）

    > 当 v $\leftarrow$ expression(c1, c2, ...) 时可以将右值表达式计算出结果以替换右值表达式。

- 无用代码消除（ `dead code elimination` ）

    > - 假设所有变量都是常量，直到该变量值改变。
    >
    > - 假设所有基本块都无法执行，直到该块被执行。
    >
    > 通过可达性分析，将常量进行折叠，并消除无用代码。

### SSA 参看书目

- [15-745 Optimizing Compilers for Modern Architectures, Spring 2016](http://link.zhihu.com/?target=http%3A//www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s16/www/)
- [Static Single Assignment Book](http://ssabook.gforge.inria.fr/latest/book.pdf)

## LLVM IR 基本语法

简要介绍 `LLVM IR` 的基本语法常用的指令，详细文档请参看[LLVM Language Reference Manual](https://llvm.org/docs/LangRef.html)。

### 基本语法

<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="comment">define dso_local i64 @_Z3fibi(i32 %n) #0 &#123;</span></span><br><span class="line"><span class="comment">entry:</span></span><br><span class="line"><span class="comment">  %retval = alloca i64, align 8</span></span><br><span class="line"><span class="comment">  %n.addr = alloca i32, align 4</span></span><br><span class="line"><span class="comment">  %result = alloca i64, align 8</span></span><br><span class="line"><span class="comment">  %f0 = alloca i64, align 8</span></span><br><span class="line"><span class="comment">  %f1 = alloca i64, align 8</span></span><br><span class="line"><span class="comment">  %i = alloca i32, align 4</span></span><br><span class="line"><span class="comment">  store i32 %n, i32* %n.addr, align 4</span></span><br><span class="line"><span class="comment">  %0 = load i32, i32* %n.addr, align 4</span></span><br><span class="line"><span class="comment">  %cmp = icmp slt i32 %0, 2</span></span><br><span class="line"><span class="comment">  br i1 %cmp, label %if.then, label %if.end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if.then:                                          ; preds = %entry</span></span><br><span class="line"><span class="comment">  %1 = load i32, i32* %n.addr, align 4</span></span><br><span class="line"><span class="comment">  %conv = sext i32 %1 to i64</span></span><br><span class="line"><span class="comment">  store i64 %conv, i64* %retval, align 8</span></span><br><span class="line"><span class="comment">  br label %return</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if.end:                                           ; preds = %entry</span></span><br><span class="line"><span class="comment">  store i64 0, i64* %result, align 8</span></span><br><span class="line"><span class="comment">  store i64 0, i64* %f0, align 8</span></span><br><span class="line"><span class="comment">  store i64 1, i64* %f1, align 8</span></span><br><span class="line"><span class="comment">  store i32 1, i32* %i, align 4</span></span><br><span class="line"><span class="comment">  br label %for.cond</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for.cond:                                         ; preds = %for.inc, %if.end</span></span><br><span class="line"><span class="comment">  %2 = load i32, i32* %i, align 4</span></span><br><span class="line"><span class="comment">  %3 = load i32, i32* %n.addr, align 4</span></span><br><span class="line"><span class="comment">  %cmp1 = icmp slt i32 %2, %3</span></span><br><span class="line"><span class="comment">  br i1 %cmp1, label %for.body, label %for.end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for.body:                                         ; preds = %for.cond</span></span><br><span class="line"><span class="comment">  %4 = load i64, i64* %f0, align 8</span></span><br><span class="line"><span class="comment">  %5 = load i64, i64* %f1, align 8</span></span><br><span class="line"><span class="comment">  %add = add nsw i64 %4, %5</span></span><br><span class="line"><span class="comment">  store i64 %add, i64* %result, align 8</span></span><br><span class="line"><span class="comment">  %6 = load i64, i64* %f1, align 8</span></span><br><span class="line"><span class="comment">  store i64 %6, i64* %f0, align 8</span></span><br><span class="line"><span class="comment">  %7 = load i64, i64* %result, align 8</span></span><br><span class="line"><span class="comment">  store i64 %7, i64* %f1, align 8</span></span><br><span class="line"><span class="comment">  br label %for.inc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for.inc:                                          ; preds = %for.body</span></span><br><span class="line"><span class="comment">  %8 = load i32, i32* %i, align 4</span></span><br><span class="line"><span class="comment">  %inc = add nsw i32 %8, 1</span></span><br><span class="line"><span class="comment">  store i32 %inc, i32* %i, align 4</span></span><br><span class="line"><span class="comment">  br label %for.cond</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for.end:                                          ; preds = %for.cond</span></span><br><span class="line"><span class="comment">  %9 = load i64, i64* %result, align 8</span></span><br><span class="line"><span class="comment">  store i64 %9, i64* %retval, align 8</span></span><br><span class="line"><span class="comment">  br label %return</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">return:                                           ; preds = %for.end, %if.then</span></span><br><span class="line"><span class="comment">  %10 = load i64, i64* %retval, align 8</span></span><br><span class="line"><span class="comment">  ret i64 %10</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>

#### 注释

`;` 表示单行注释的开始。

#### 标识符

`LLVM IR` 中的标识符分为两种类型：全局的和局部的。全局的标识符包括函数名和全局变量，会加一个 `@` 前缀，局部的标识符会加一个 `%` 前缀。一般地，可用标识符对应的正则表达式为：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*</span><br></pre></td></tr></table></figure>

#### 函数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define dso_local i64 @_Z3fibi(i32 %n) #0</span><br></pre></td></tr></table></figure>

定义了一个函数，其中 `i64` 代表 `64` 位整数，即 `C/C++` 中的 `int`；`@_Z3fibi` 是函数名且代表函数是全局的；括号内是参数列表。`#0` 是指向函数属性的标记符。



### 数据类型

#### 数组

##### 语法

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;elementnumber&gt; x &lt;elementtype&gt;]</span><br></pre></td></tr></table></figure>

数据元素在内存中是连续存储的。对于索引超出静态类型所指定的数组末端没有限制（尽管在某些情况下对于索引超出已分配对象的边界有限制）。这意味着一维”可变大小数组“寻址可以在零长度数组类型的 `LLVM` 中实现。例如，`LLVM` 中 `pascal` 风格数组的实现可以使用 `{i32， [0 x float]}` 类型。

#### 结构体

##### 语法

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%T1 &#x3D; type &#123; &lt;type list&gt; &#125;     ; Identified normal struct type</span><br><span class="line">%T2 &#x3D; type &lt;&#123; &lt;type list&gt; &#125;&gt;   ; Identified packed struct type</span><br></pre></td></tr></table></figure>

结构类型用于表示内存中的数据成员集合。结构的元素可以是任何具有大小的类型。


通过使用 `getelementptr` 指令获得指向字段的指针，可以使用 `load` 和 `store` 访问内存中的结构。使用`extractvalue` 和 `insertvalue` 指令访问寄存器中的结构。


结构可以选择“打包”结构，这表示结构的对齐方式是一个字节，并且元素之间没有填充。在非打包结构中，字段类型之间的填充是由模块中的 `DataLayout` 字符串定义的，这是匹配底层代码生成器所期望的内容所必需的。

### 常用指令

#### alloca

##### 语法

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; &#x3D; alloca [inalloca] &lt;type&gt; [, &lt;ty&gt; &lt;NumElements&gt;] [, align &lt;alignment&gt;] [, addrspace(&lt;num&gt;)]     ; yields type addrspace(num)*:result</span><br></pre></td></tr></table></figure>

返回一个指针。分配的内存是未初始化的，从未初始化的内存中加载会产生一个未定义的值。如果分配的堆栈空间不足，则操作本身未定义。

`alloca` 指令也可以用来分配结构体。

#### load

##### 语法

`load` 的语法较为复杂，具有多种形式，但常用的形式一般如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%0 &#x3D; load i32, i32* %n.addr, align 4 &#x2F;&#x2F; 从地址%n.addr中读取i32型数据</span><br></pre></td></tr></table></figure>

#### store

##### 语法

`store` 的语法较为复杂，具有多种形式，但常用的形式一般如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store i32 %n, i32* %n.addr, align 4 &#x2F;&#x2F; 向地址%n.addr中读取i32型数据%n</span><br></pre></td></tr></table></figure>

#### call

##### 语法

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; &#x3D; [tail | musttail | notail ] call [fast-math flags] [cconv] [ret attrs] [addrspace(&lt;num&gt;)]</span><br><span class="line">           &lt;ty&gt;|&lt;fnty&gt; &lt;fnptrval&gt;(&lt;function args&gt;) [fn attrs] [ operand bundles ]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%call2 &#x3D; call i64 @_Z3fibi(i32 %1) &#x2F;&#x2F; 调用fib函数，返回值赋给%call2</span><br></pre></td></tr></table></figure>

#### ret

##### 语法

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret &lt;type&gt; &lt;value&gt;       ; Return a value from a non-void function</span><br><span class="line">ret void                 ; Return from void function</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret i64 %10 &#x2F;&#x2F; 返回%10</span><br></pre></td></tr></table></figure>

#### br

##### 语法

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">br i1 &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt;</span><br><span class="line">br label &lt;dest&gt;          ; Unconditional branch</span><br></pre></td></tr></table></figure>

在执行条件 `br` 指令时，将对 `i1` 参数求值。如果该值为真，则控制流到 `iftrue` 标签参数。如果 `cond` 为假，则控制流到 `iffalse` 标签参数。`br` 指令的无条件形式以单个 `label` 值为目标。

#### phi

##### 语法

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; &#x3D; phi [fast-math-flags] &lt;ty&gt; [ &lt;val0&gt;, &lt;label0&gt;], ...</span><br></pre></td></tr></table></figure>

`phi` 指令在逻辑上接受在当前块之前执行的前任基本块对应所指定的值。

![phi](phi.jpg)

`phi` 指令主要用来解决 `SSA` （静态单赋值）带来的问题。不过 `SSA` 带来的变量不能重复赋值问题也能通过指针来解决，可以向一个不变的地址上多次执行 `store` 指令从而实现多次赋值。

要想在 `LLVM IR` 中使用 `phi` 指令，可以应用 `-mem2reg` 优化：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang++ fib.cpp -Xclang -disable-O0-optnone -emit-llvm -S -o fib.ll </span><br><span class="line">opt -mem2reg -S fib.ll -o fib-opt.ll</span><br></pre></td></tr></table></figure>

注意仍然要添加 `-Xclang -disable-O0-optnone` 编译。

同理要想在 `LLVM IR` 中屏蔽 `phi` 指令，可以应用 `-reg2mem` 优化（默认情况下即使不使用 `phi` 指令）：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang++ fib.cpp -Xclang -disable-O0-optnone -emit-llvm -S -o fib.ll </span><br><span class="line">opt -reg2mem -S fib.ll -o fib-opt.ll</span><br></pre></td></tr></table></figure>

#### getelementptr (GEP)

##### 语法

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; &#x3D; getelementptr &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;&#123;, [inrange] &lt;ty&gt; &lt;idx&gt;&#125;*</span><br><span class="line">&lt;result&gt; &#x3D; getelementptr inbounds &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;&#123;, [inrange] &lt;ty&gt; &lt;idx&gt;&#125;*</span><br><span class="line">&lt;result&gt; &#x3D; getelementptr &lt;ty&gt;, &lt;ptr vector&gt; &lt;ptrval&gt;, [inrange] &lt;vector index type&gt; &lt;idx&gt;</span><br></pre></td></tr></table></figure>

第一个`ty`是第一个索引使用的基本类型，第二个 `ty` 表示其后的基址`ptrval`的类型。`<ty> <idx>` 是第一组索引的类型和值，`<ty> <idx>`可以出现多次，其后出现的就是第二组、第三组等等索引的类型和值。要注意索引的类型和索引使用的基本类型是不一样的，索引的类型一般为`i32`或`i64`，而索引使用的基本类型确定的是增加索引值时指针的偏移量。

##### 理解第一个索引

1. 第一个索引不会改变返回的指针的类型，也就是说 `ptrval` 前面的 `*` 对应什么类型，返回就是什么类型
2. 第一个索引的偏移量的是由第一个索引的值和第一个 `ty` 指定的基本类型共同确定的。

![gep1](gep1.jpg)

上图中第一个索引所使用的基本类型是 `[6 x i8]`，值是1，所以返回的值相对基址 `@a_gv` 前进了 `6` 个字节。由于只有一个索引，所以返回的指针也是 `[6 x i8]*` 类型。

##### 理解后面的索引

1. 后面的索引是在 `Aggregate Types` 内进行索引。

2. 每增加一个索引，就会使得该索引使用的基本类型和返回的指针的类型去掉一层。

![gep2](gep2.jpg)

我们看 `%elem_ptr = getelementptr [6 x i8], [6 x i8]* @a_gv, i32 0, i32 0` 这一句，第一个索引值是 `0`，使用的基本类型 `[6 x i8]` , 因此其使返回的指针先前进 `0 x 6` 个字节，也就是不前进，第二个索引的值是 `1`，使用的基本类型就是 `i8`（ `[6 x i8]`去掉左边的 `6` ），因此其使返回的指针前进一个字节，返回的指针类型为 `i8*`（ `[6 x i8]*`去掉左边的 `6` ）。

##### GEP如何作用于结构体

![gep3](gep3.jpg)

只有一个索引情况下， `GEP` 作用于结构体与作用于数组的规则相同，`%new_ptr = getelementptr %MyStruct*, %MyStruct* @a_gv, i32 1 `使得 `%new_ptr` 相对 `@a_gv` 偏移一个结构体 `%MyStruct` 的大小。

![gep4](gep4.jpg)

在有两个索引的情况下，第二个索引对返回指针的影响跟结构体的成员类型有关。譬如说在上图中，第二个索引值是 `1`，那么返回的指针就会偏移到第二个成员，也就是偏移 `1` 个字节，由于第二个成员是 `i32` 类型，因此返回的指针是 `i32* ` 。

![gep5](gep5.jpg)

如果结构体的本身也有 `Aggregate Type` 的成员，就会出现超过两个索引的情况。第三个索引将会进入这个`Aggregate  Type` 成员进行索引。譬如说上图中的第二个索引是 `2` ，指针先指向第三个成员，第三个成员是个数组。再看第三个索引是 `0` ，因此指针就指向该成员的第一个元素，指针类型也变成了 `i32*` 。

**注：** 本 `GEP` 小节引用了知乎用户[@ZRN-BF](https://www.zhihu.com/people/guo-ai-54)的文章[A Tour to LLVM IR（下）](https://zhuanlan.zhihu.com/p/66909226)。



## Clang 介绍

上文已经提到 `Clang`只是前端的一个 `Driver` ，从编译器架构上来说，`Clang ` 只是用来进行词法分析、语法分析、语义分析、中间代码生成的编译器前端。 `Clang` 需要借助其他编译器后端来实现机器代码生成。这也是`Clang` 的 `Target Information` 的作用。 `Windows` 上 `Clang` 可以与 `MSVC` 或 `MinGW` 搭配起来构成一个完整的编译器。

`Clang` 生成中间代码（也就是 `LLVM ` 字节码），并在此基础上进行一系列优化操作，再进一步生成可执行文件。由于 `Clang` 需要和其他的编译器后端组合，所以在编程源码时就会出现许多由于前后端不搭配导致的问题。



### Clang 交叉编译

前后端的 `target` 不同，可以在编译时添加 `--target` 选项来指定后端  `target` ，具体参看[Target Information](# Target Information)。



### Clang 异常处理模型

首先介绍一下 `MinGW-w64` 的异常模型的异同，可以参看[GCC Wiki](https://gcc.gnu.org/wiki/WindowsGCCImprovements) 和 [Stackoverflow](https://stackoverflow.com/questions/15670169/what-is-difference-between-sjlj-vs-dwarf-vs-seh)：

- `SJLJ`（`setjmp` / `longjmp` ）： 支持 `32` 位和 `64 ` 位系统。传统的异常处理模型，性能较差即使没有抛出异常，也会导致较小的性能损失（严重异常代码的性能损失约为 `15%` ），但有时这种损失可能更大。
- `SEH` （`Structured Exception Handling` ）： 只支持  `64` 位系统。性能更加优异，当从不使用 `SEH` 的库z中抛出异常时，`SEH` 异常将导致非常糟糕的事情发生。
- `DWARF` ：只支持  `32` 位系统。需要使用 `DWARF-2`（或 `DWARF-3` ）调试信息。`DW2 EH` 会导致可执行文件稍微膨胀，因为大型的调用堆栈展开表必须包含在可执行文件中。

一般情况下，`x86_64` 可选为 `seh` 和 `sjlj`，`i686` 为`dwarf` 和 `sjlj` 。你可以通过这个[回答](https://stackoverflow.com/questions/17967597/obtaining-current-gcc-exception-model)中的方法查看 `Clang` 和 `GCC` 的当前的异常处理模型，也可以阅读 [Exceptions Handling in LLVM](http://llvm.org/docs/ExceptionHandling.html#itanium-abi-zero-cost-exception-handling)。

普通 `Windows` 用户在使用 `Clang` 时可能更倾向于使用官网预编译的二进制版本直接安装，官网的编译版本通常是：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Target: x86_64-pc-windows-msvc</span><br><span class="line">Thread model: posix</span><br></pre></td></tr></table></figure>

预编译 `Clang` 默认的异常处理模型为 `seh` 。如果你使用 `MSVC` 作为后端，那么可能没有问题，因为 `MSVC` 同样使用 `seh` 。但如果你使用 `MinGW` 作为后端，就需要查看 `MinGW` 的异常处理模型是否与 `Clang` 默认的异常处理模型相同，如果不同， 可以添加 `-fdwarf-exceptions` 、 `-fsjlj-exceptions` 和 `-fseh-exceptions` 来指定异常处理模型，或者添加 `-fno-exceptions` 禁用异常机制（一般不建议）。



### Clang 编译流程

![process1](process1.jpg)
![process2](process2.png)

1. `Clang` 或 `Clang++` (以下以 `clang++` 为例说明，如有两者不同的特殊情况会专门指出）对待编译的源文件 `main.cpp`  进行预处理，例如将 `#include` 的文件复制到源文件中、展开宏定义、插入内联函数以及处理 `#if` 、`#endif` 、`#ifndef` 等命令。使用 `-E` 选项指定编译器只进行预处理。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ main.cpp -E -o main.i</span><br></pre></td></tr></table></figure>

2. `Clang++` 将 `main.i` 编译为汇编代码文件。使用`-S` 选项指定编译器只进行预处理和编译。若添加上 `-emit-llvm` 选项，则会生成 `LLVM IR`（一种 `LLVM` 专用的中间表示，类似于汇编的可读的字节码）文件，否则会生成一般汇编代码文件。

    **注：** `Clang` 的 `Release` 和 `Debug` 版生成的 `.ll` 文件略有不同，`Release` 版默认生成的 `.ll` 文件会丢弃变量的名字，你可以添加 `-fno-discard-value-names` 选项指定 `Clang` 保留原有的标签和标识符以增加可读性。

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang++ main.cpp -S -o main.s</span><br><span class="line">clang++ main.cpp -S -emit-llvm -o main.ll</span><br></pre></td></tr></table></figure>

3. `Clang++` 将汇编代码文件进行汇编生成 `LLVM bitcode` （专指 `.bc` 文件）文件。使用`-c` 选项指定编译器只进行预处理、编译和汇编。若添加上 `-emit-llvm` 选项，则会生成 `LLVM bitcode` 文件，否则会生成 `.obj` 文件。

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang++ main.cpp -c -o main.o</span><br><span class="line">clang++ main.cpp -c -emit-llvm -o main.bc</span><br></pre></td></tr></table></figure>

    ![compile](compile.JPG)

4. `Clang++` 将多个 `.obj` 文件或 `LLVM bitcode` 文件链接起来，形成一个完整的文件。使用 `-r` 选项指定编译器只进行符号链接，把多个 `.obj` 文件链接为一个总的 `.obj` 文件。

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ main.o factorial.o -r -o linked.o</span><br></pre></td></tr></table></figure>

    ![link](link.JPG)

    **注：** 

    1. `libstdc++`  、`libc++`  和 `msvcrt` 都是 `C++` 标准库的一个实现。 `libstdc++` 是 `Linux` 上 `GCC` 的默认运行时库； `libc++` 是 `Mac OS` 上 `Clang` 的配套运行时库； `msvcrt` 是 `Windows` 上 `VS` 的默认运行时库。

    2. `C++` 会进行 `Name Mangling` ， `Name Mangling` 是将函数名和变量名编码为惟一的名称，以便链接器能够将语言中的名称区分开，以便实现重载。 `Name Mangling` 按照一定规则根据函数名和函数参数列表生成混淆后的函数名。

        使用以下命令可以得到混淆前的函数签名：

        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c++filt -n &lt;mangled-name&gt;</span><br></pre></td></tr></table></figure>

        

5. `Clang++` 将 `.obj` 文件编译生成可执行文件。

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ linked.o -o main.exe</span><br></pre></td></tr></table></figure>

**注意：**

1. `clang` 和 `clang++` 只是前端的一个 `Driver` （驱动程序），`clang` 和 `clang++` 对源文件的处理本质上都是通过调用 `LLVM` 工具链实现的。`Clang` 的命令行用法参看[文档](https://clang.llvm.org/docs/CommandGuide/clang.html)。

2. `clang` 和 `clang++` 在预处理、编译和汇编阶段是完全相同，`clang++` 本质上是 `clang` 的一个软连接，它通过后缀名来判断是 `C` 还是 `C++`，` -x <language>` 会指定文件语言类型 。不同的是 `clang++` 既可以链接 `C++` 标准库也可以链接 `C` 标准库，`clang` 只能链接 `C` 标准库。

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clang++ test.c -o test.exe &#x2F;&#x2F; correct</span><br><span class="line">clang test.cpp -o test.exe &#x2F;&#x2F; error</span><br><span class="line">clang test.cpp -c -o test.o &#x2F;&#x2F; correct, because clang works same as clang++ during preprocess, compile and assemble steps</span><br><span class="line">clang test.cpp -stdc++ -o test.exe &#x2F;&#x2F; correct, clang complie successfully after specifing link library</span><br></pre></td></tr></table></figure>

    

#### Clang 编译选项

`Clang` 兼容 `gcc` 的所有编译选项，同时`Clang` 有附带许多功能，我们可以通过添加编译选项来使用。



#### `-m32` 和 `-m64` 

使用 `32` 位的 `clang` 或 `gcc` 时默认生成 `32` 位的程序；使用 `64` 位的 `clang` 或 `gcc` 时默认生成 `64` 位的程序。

当 `Windows` 下使用 `64` 位的 `gcc` 编译 `32` 位的程序时，必须将对应的动态链接库地址加入到 `PATH` 环境变量（ `Linux` 下可以设置 `LD_LIBRARY_PATH` ）中，或者在编译时选择静态链接。

**注:**  `clang` 对 `32` 位和 `64` 位交叉编译配置较为麻烦，远不如直接使用 `MinGW-w64` 。配置交叉编译的选项最好使用专门的构建工具（如 `CMake` , `Makefile` ），直接配置环境变量不仅费时费力，而且环境变量是全局的，对编译其他程序极不友好，很容易造成冲突。





#### `-ftime-trace`

`Clang 9.0.0`  增加了 `-ftime-trace` ， 这能够以友好的格式生成时间跟踪分析数据，对于开发人员更好地理解编译器将大部分时间花在何处以及其他需要改进的领域非常有用。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; clang++ test.cpp -ftime-trace -c -o test.o</span><br><span class="line">Time trace json-file dumped to test.json</span><br><span class="line">Use chrome:&#x2F;&#x2F;tracing or Speedscope App (https:&#x2F;&#x2F;www.speedscope.app) for flamegraph visualization</span><br></pre></td></tr></table></figure>

在[speedscope](https://www.speedscope.app)中你可以看到以下的交互可视化图形：

![visualize1](visualize1.png)

![visualize2](visualize2.png)

[`Clang Build Analyzer`](https://github.com/aras-p/ClangBuildAnalyzer)工具有助于聚合来自多个编译的时间跟踪报告，并输出关于“什么花了最多的时间”的信息摘要。



#### `--analyze`

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang --analyze -Xclang -analyzer-checker&#x3D;&quot;cplusplus&quot; test.cpp</span><br><span class="line">clang --analyze -Xanalyzer -analyzer-checker&#x3D;&quot;cplusplus&quot; test.cpp</span><br></pre></td></tr></table></figure>

`--analyze` 选项启动 `Clang` 的静态代码分析，能够检查代码中存在的错误与缺陷。 `Clang` 可以检查进行特定的检查（ `checker` ），`Clang` 内置的 `checker` 查看[available_checks](http://clang-analyzer.llvm.org/available_checks.html)。





### Clang 拓展

#### clang-format

`clang-format` 是一个代码格式化工具，`clang-format` 内建了 `LLVM`，`Google`，`Chromium`， `Mozilla`， `WebKit` 五种格式，可以通过 `--style=` 指定，也可以使用 `--style=file` 从 `.clang-format` 文件中加载自定义代码格式配置（ **`clang-format` 的配置文件名必须是 `.clang-format`** ）。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format --style&#x3D;LLVM -i main.cpp</span><br></pre></td></tr></table></figure>

`-i` 选项指定就地更改 `main.cpp `。

#### clang-tidy

`clang-tidy` 是一个基于 `clang` 的 `C++` `linter`工具。它的目的是提供一个可扩展的框架，用于诊断和修复典型的编程错误，如样式违规、接口误用或可以通过静态分析推断出的 `bug` 。`clang-tidy` 是模块化的，提供了一个方便的接口来编写新的插件。`clang-tidy` 提供了许多 `check `，可以在 `-check=` 中指定一个或多个 `check`  （用 `,` 隔开）其他详细用法查看[官网](http://clang-analyzer.llvm.org)。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-tidy -checks&#x3D;-*,clang-analyzer-*,-clang-analyzer-cplusplus* test.cpp --</span><br></pre></td></tr></table></figure>

**注：**

1.  `Windows` 下使用要在命令行最后添加 `--` 。
2. `Windows` 下 `clang-tidy` 的 `-check` 和 `-config` 选项组合在一起可能会出现问题，可以把所有选项都放在 `-config` 中。

#### clang-check

`clang-check` 与 `clang-tidy` 功能类似，在没有显示指定任何选项的情况下运行 `clang-check` 将运行 `-fsyntax-only` 模式（检查语法是否正确）。只有在指定 `-analyze` 时，才会执行静态分析工具，**但不能同时指定 `-fsyntax-only` 和 `-analyze`**，`-check` 选项可以参考[官网](http://clang-analyzer.llvm.org/)。

`clang-check` 还可以输出代码的 `AST` ，具体用法执行 `clang-check -help` 。

### LLVM 优化

`clang` 一般只有在开启优化时才会内联函数，如果使用 `-fno-inline` 选项或 `-O0` 优化级别（默认优化级别），`GCC` 将不内联任何函数，可以使用 `-Winline` 选项来确定函数是否没有内联以及为什么没有内联。此时可以使用 `__attribute__` 机制。

在函数声明末尾 `;` 之前添加 `__attribute__((always_inline))` ，可以强制编译器内联函数（尽可能内联，必须满足内联函数要求）。

**`C++` 中内联编译限制：**

1. 不能存在任何形式的循环语句。
2. 不能存在过多的条件判断语句。
3. 函数体不能过于庞大。
4. 不能对函数进行取址操作。
5. 内联函数声明必须在调用语句之前。

### Clang 使用中遇到的问题

1. `MinGW-w64` 与 `float.h`  不兼容：

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">G:\mingw64\x86_64-w64-mingw32\include\float.h:28:15: fatal error: &#39;float.h&#39; file not found</span><br><span class="line">#include_next &lt;float.h&gt;</span><br></pre></td></tr></table></figure>

    查看 ['float.h' file not found-StackOverflow](https://stackoverflow.com/questions/57166340/how-do-i-compile-code-using-clang-with-the-mingw-c-c-library-particular-issu)。

2. `member [...] in archive is not an object`  一般有2个原因：

    1. 链接的对象或库文件位数不一致，例如 `x64` 和 `x86` 混合。
    2. 使用 `LTO` 时没有在编译和链接时都添加上 `flto` 。

3. 链接静态库时出现 `error: undefined reference to 'xxx'` ，一般是由于缺少库文件或者链接顺序错误。被链接的库应该放在最后面。

## _参考资料_

[1] [RednaxelaFX Blog](https://www.iteye.com/blog/user/rednaxelafx)</language></idx></ty></idx></ty>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/19/Test/" rel="prev" title="Test">
      <i class="fa fa-chevron-left"></i> Test
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">李太吉</p>
  <div class="site-description" itemprop="description">NPUer</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李太吉</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
