<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="NPUer">
<meta property="og:type" content="website">
<meta property="og:title" content="李太吉的技术博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="李太吉的技术博客">
<meta property="og:description" content="NPUer">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="李太吉">
<meta property="article:tag" content="C&#x2F;C++ Java Rust">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>李太吉的技术博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李太吉的技术博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">人生到处知何似 应似飞鸿踏雪泥</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/19/%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E8%BE%93%E5%87%BA%E5%A4%A7%E5%B0%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%9F%90%E4%BA%9B%E5%9B%A0%E7%B4%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李太吉">
      <meta itemprop="description" content="NPUer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李太吉的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/19/%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E8%BE%93%E5%87%BA%E5%A4%A7%E5%B0%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%9F%90%E4%BA%9B%E5%9B%A0%E7%B4%A0/" class="post-title-link" itemprop="url">与编译器编译输出大小相关的某些因素</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-19 18:56:08 / 修改时间：18:59:15" itemprop="dateCreated datePublished" datetime="2020-07-19T18:56:08+08:00">2020-07-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="与编译器编译输出大小相关的某些因素"><a href="#与编译器编译输出大小相关的某些因素" class="headerlink" title="与编译器编译输出大小相关的某些因素"></a>与编译器编译输出大小相关的某些因素</h1><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>在编译一个极其简单的 <code>C++</code> 入门示例（ <code>test.cpp</code> ）的时候，发现 <code>Code::Blocks</code> 编译的结果比 <code>Visual Studio</code> 编译的结果大许多。</p>
<h2 id="研究过程"><a href="#研究过程" class="headerlink" title="研究过程"></a>研究过程</h2><p>我们使用如下工具，对 <code>test.cpp</code> 文件进行编译测试，探究与编译器编译输出大小相关的因素。</p>
<h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><ul>
<li><code>Code::Blocks 17.12</code> 与 <code>GCC 5.1.0</code></li>
<li><code>Visual Studio 2017</code> 与 <code>MSVC++ 15.0</code></li>
<li><code>GCC 8.1.0</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h3><p>一般来说，不同的 <code>IDE</code> 都有不同的默认编译选项。我们先用命令行复原模拟 <code>Code::Blocks 17.12</code> 和 <code>Visual Studio 2017</code> 的编译过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Code::Blocks 17.12</span><br><span class="line">mingw32-g++ test.cpp -c -o test.o</span><br><span class="line">mingw32-g++ test.o -o test.exe</span><br></pre></td></tr></table></figure>
<p>输出大小为 <code>1528KB</code> 。对于如此简单的代码，这个大小可以说相当大了。<br> <code>VS</code> 的编译过程较为复杂，我们不再用命令行模拟，但 <code>VS</code> 的编译输出大小只用 <code>193KB</code> 。</p>
<h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><p>问题可以重现，也就代表这个问题背后有较为稳定的原因，多半是代码造成的结果，而不是玄学导致的，我们也就不用玄学排错了。由于很难用命令行模拟VS编译，我们下面就主要使用 <code>GCC 5.1.0</code> 进行测试。</p>
<p>很容易想到是不是静态链接和动态链接的原因，我们先用 <code>-static</code> 编译选项看一下静态链接编译输出的大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; GCC 5.1.0</span><br><span class="line">mingw32-g++ test.cpp -c -o test.o</span><br><span class="line">mingw32-g++ test.o -static -o test.exe</span><br></pre></td></tr></table></figure>
<p>输出大小为 <code>1528KB</code> ，和之前完全一样。为什么静态链接会和动态链接的编译输出一样大？我们查看 <code>GCC</code> 的安装目录，我们可以看到它压根就没有动态库，全部是 <code>.a</code> 静态链接库文件。</p>
<p><img src="/2020/07/19/%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E8%BE%93%E5%87%BA%E5%A4%A7%E5%B0%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%9F%90%E4%BA%9B%E5%9B%A0%E7%B4%A0/screenshot.png" alt="image"></p>
<p>至此可以说仅就这个问题来说算是找到答案了。 <code>Code::Blocks</code> 下载时配套的编译器为<code>GCC 5.1.0</code>，而该编译器没有携带动态库，只支持静态链接（也就是说不管添不添加<code>-static</code>编译选项，都是静态链接）。相反，<code>VS</code>下载时一并下载了<code>Windows SDK</code>，里面包含了 <code>C Runtime Library</code> （C运行时库），而且既有静态运行时库，也有动态运行时库，因此 <code>Visual Studio</code> 支持静态链接和动态链接， <code>Visual Studio</code> 使用动态链接编译的结果显然比<code>Code::Blocks</code>使用静态链接 编译的结果小许多。</p>
<p>我们用携带动态链接库的 <code>GCC 8.1.0</code> 编译该文件，得到的输出结果大小只有<code>56KB</code>，甚至比 <code>VS</code> 的还要小（当然通过修改编译选项， <code>VS</code> 的输出结果也能做到这么小，甚至更小，毕竟<code>GCC</code>开源， <code>VS</code> 有微软的技术支撑，而且 <code>GCC</code> 本来就不是 <code>Windows</code> 平台的原生编译器，对 <code>Windows</code> 的支持一定没有微软自家好）。</p>
<h2 id="拓展研究"><a href="#拓展研究" class="headerlink" title="拓展研究"></a>拓展研究</h2><h3 id="Release-和-Debug"><a href="#Release-和-Debug" class="headerlink" title="Release 和 Debug"></a><code>Release</code> 和 <code>Debug</code></h3><p>我们比较<code>Release</code> 和 <code>Dubug</code>两个版本的编译输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; GCC 8.1.0</span><br><span class="line">&#x2F;&#x2F; Debug</span><br><span class="line">g++ test.cpp -g -o test.exe</span><br><span class="line">&#x2F;&#x2F; Release</span><br><span class="line">g++ test.cpp -s -o test.exe</span><br></pre></td></tr></table></figure>
<p><code>Debug</code> 版有 <code>75KB</code> ， <code>Release</code> 版有 <code>56KB</code> 。对于我们的测试代码差别不大，但大型项目的 <code>Release</code> 和 <code>Debug</code> 版本大小就会相差悬殊。</p>
<h3 id="编译器的版本"><a href="#编译器的版本" class="headerlink" title="编译器的版本"></a>编译器的版本</h3><p>不同的编译器或者同一编译器的不同版本生成的编译输出大小可能就不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; GCC 8.1.0</span><br><span class="line">g++ test.cpp -static -o test.exe</span><br></pre></td></tr></table></figure>
<p>生成的编译输出大小为<code>2552KB</code>，比<code>GCC 5.1.0</code>还要大。<del>猜测可能是因为要支持更新的<code>C++ 20</code>标准，链接了更多的文件。</del></p>
<h3 id="IDE和编译器添加的其它优化"><a href="#IDE和编译器添加的其它优化" class="headerlink" title="IDE和编译器添加的其它优化"></a><code>IDE</code>和编译器添加的其它优化</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>与编译器编译输出大小相关的因素一般有如下几个原因</p>
<ol>
<li>编译器的链接选项不同，静态链接比动态链接更小（支持动态链接的前提是你要有动态库，不然编译选项是不管用的）。</li>
<li>编译器可以生成 <code>Release</code> 版和 <code>Debug</code> 版，后者包含调试信息，一般来说体积更大。</li>
<li>编译器不同，更新版本的编译器生成的代码可能<del>更小</del>更小或更大。</li>
<li><code>IDE</code> 和编译器添加了其他的优化选项。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/19/Windows-bat%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李太吉">
      <meta itemprop="description" content="NPUer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李太吉的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/19/Windows-bat%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">Windows bat语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-19 18:54:04 / 修改时间：18:58:57" itemprop="dateCreated datePublished" datetime="2020-07-19T18:54:04+08:00">2020-07-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Windows-bat-语法"><a href="#Windows-bat-语法" class="headerlink" title="Windows bat 语法"></a>Windows bat 语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>::</code></td>
<td>注释无回显</td>
</tr>
<tr>
<td><code>rem</code></td>
<td>注释有回显</td>
</tr>
</tbody>
</table>
</div>
<h2 id="命令帮助"><a href="#命令帮助" class="headerlink" title="命令帮助"></a>命令帮助</h2><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;command&gt; /?</code></td>
<td>返回 <code>&lt;command&gt;</code> 命令的帮助</td>
</tr>
</tbody>
</table>
</div>
<h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>echo text</code></td>
<td>在命令行中回显 <code>text</code></td>
</tr>
<tr>
<td><code>echo off</code></td>
<td>从下一行开始关闭回显</td>
</tr>
<tr>
<td><code>@echo off</code></td>
<td>从本行开始关闭回显</td>
</tr>
<tr>
<td><code>echo on</code></td>
<td>从下一行开始开启回显</td>
</tr>
<tr>
<td><code>@echo on</code></td>
<td>从本行开始开启回显</td>
</tr>
</tbody>
</table>
</div>
<h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dir</code></td>
<td>显示当前目录中的文件和子目录</td>
</tr>
<tr>
<td><code>dir /a</code></td>
<td>显示当前目录中的文件和子目录，包括隐藏文件和系统文件</td>
</tr>
<tr>
<td><code>dir  /a:d</code></td>
<td>显示当前目录中的目录</td>
</tr>
<tr>
<td><code>dir  /a:-d</code></td>
<td>显示 当前目录中的文件</td>
</tr>
<tr>
<td><code>dir  /b/p</code></td>
<td><code>/b</code> 只显示文件名，<code>/p</code> 分页显示</td>
</tr>
<tr>
<td><code>dir *.exe /s</code></td>
<td>显示当前目录和子目录里所有的 <code>.exe</code> 文件。通配符 <code>*</code> ，<code>?</code> 。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cd ..</code></td>
<td>返回上一级目录</td>
</tr>
<tr>
<td><code>cd /d &lt;path&gt;</code></td>
<td>同时改变盘符和目录</td>
</tr>
</tbody>
</table>
</div>
<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>`md</td>
<td>mkdir <path></path>`</td>
<td>创建目录(包含子目录)</td>
</tr>
<tr>
<td>`rd</td>
<td>rmdir <path></path>`</td>
<td>删除空目录</td>
</tr>
<tr>
<td><code>rd /q/s &lt;path&gt;</code></td>
<td><code>/q</code> 安静模式 ，<code>/s</code> 递归</td>
</tr>
<tr>
<td>`ren</td>
<td>rename <oldName> <newName>`</newName></oldName></td>
<td>将目录 <code>oldName</code> 重命名为 <code>newName</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="pushd-和-popd"><a href="#pushd-和-popd" class="headerlink" title="pushd 和 popd"></a>pushd 和 popd</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pushd &lt;path&gt;</span><br></pre></td></tr></table></figure>
<p>保存当前目录，并切换当前目录为 <code>&lt;path&gt;</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popd</span><br></pre></td></tr></table></figure>
<p>恢复当前目录为栈顶目录。</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cd &gt; test.txt</code></td>
<td>创建文件 <code>test.txt</code> ，可以使用 <code>&gt;</code> 重定位操作符创建文件并写入数据</td>
</tr>
<tr>
<td><code>type test.txt</code></td>
<td>查看文件 <code>test.txt</code> 内容</td>
</tr>
<tr>
<td><code>del test.txt</code></td>
<td>删除文件 <code>test.txt</code> ，不能是隐藏、系统、只读文件</td>
</tr>
<tr>
<td><code>del /q/a/f d:\temp\*.*</code></td>
<td>删除 <code>d:\temp</code> 文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录</td>
</tr>
<tr>
<td><code>del /q/a/f/s d:\temp\*.*</code></td>
<td>#删除 <code>d:\temp</code> 及子文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录</td>
</tr>
</tbody>
</table>
</div>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>copy key.txt c:\doc</code></td>
<td>将当前目录下的 <code>key.txt</code> 拷贝到 <code>c:\doc</code> 下（若 <code>doc</code> 中也存在一个 <code>key.txt</code> 文件，会询问是否覆盖）</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/Y</code></td>
<td>不使用确认是否要覆盖现有目标文件</td>
</tr>
<tr>
<td><code>/-Y</code></td>
<td>使用确认是否要覆盖现有目标文件的提示</td>
</tr>
</tbody>
</table>
</div>
<h3 id="xcopy"><a href="#xcopy" class="headerlink" title="xcopy"></a>xcopy</h3><p><code>xcopy</code>命令类似<code>copy</code>，但功能更加强大。</p>
<h3 id="move"><a href="#move" class="headerlink" title="move"></a>move</h3><p><code>move</code>指令的用法基本同上。</p>
<h2 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h2><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>显示和设置当前日期。在 <code>bat</code> 文件中用 <code>%date%</code> 来调用当前日期，格式一般为 <code>yyyy/MM/dd 周一</code> 。</p>
<h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p>显示和设置当前日期。在 <code>bat</code> 文件中用 <code>%time%</code> 来调用当前日期，格式一般为 <code>HH:mm:ss.cc</code>，<code>cc</code>为<code>0.01s</code> 。</p>
<p>可以使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:: 均为中文系统下</span><br><span class="line"><span class="built_in">set</span> year = %date:~,4%</span><br><span class="line"><span class="built_in">set</span> month = %date:~5,2%</span><br><span class="line"><span class="built_in">set</span> day = %date:~8,2%</span><br><span class="line"><span class="built_in">set</span> dayofweek = %date:~11,2%</span><br><span class="line"><span class="built_in">set</span> hour = %time:~0,2% </span><br><span class="line"><span class="built_in">set</span> minute = %time:~3,2%</span><br><span class="line"><span class="built_in">set</span> second = %time:~6,2%</span><br></pre></td></tr></table></figure>
<h2 id="控制流操作"><a href="#控制流操作" class="headerlink" title="控制流操作"></a>控制流操作</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IF [NOT] ERRORLEVEL number <span class="built_in">command</span></span><br><span class="line">IF [NOT] string1 == string2 <span class="built_in">command</span></span><br><span class="line">IF [NOT] EXIST filename <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
<p>根据条件决定是否执行 <code>command</code> 。</p>
<p><strong>注：</strong></p>
<ol>
<li><code>ELSE</code> 子句必须出现在同一行上的 <code>IF</code> 之后</li>
<li><code>ELSE</code> 命令必须与 <code>IF</code> 命令的尾端在同一行上。</li>
<li>最好将 <code>IF</code> 和 <code>ELSE</code> 子句中的 <code>command</code> 用 <code>()</code> 包围起来。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IF [/I] string1 compare-op string2 <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>/I</code> 指定比较不区分大小写；<code>compare-op</code>可以是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>EQU</td>
<td>等于</td>
</tr>
<tr>
<td>NEQ</td>
<td>不等于</td>
</tr>
<tr>
<td>LSS</td>
<td>小于</td>
</tr>
<tr>
<td>LEQ</td>
<td>小于或等于</td>
</tr>
<tr>
<td>GTR</td>
<td>大于</td>
</tr>
<tr>
<td>GEQ</td>
<td>大于或等于</td>
</tr>
</tbody>
</table>
</div>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOR %variable IN (<span class="built_in">set</span>) DO <span class="built_in">command</span> [<span class="built_in">command</span>-parameters]</span><br></pre></td></tr></table></figure>
<p>在批处理程序中使用 <code>FOR</code> 命令时，指定变量请使用 <code>%%variable</code> ，而不要用 <code>%variable</code>。变量名称是区分大小写的，所以 <code>%i</code> 不同于 <code>%I</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOR /D %variable IN (<span class="built_in">set</span>) DO <span class="built_in">command</span> [<span class="built_in">command</span>-parameters]</span><br></pre></td></tr></table></figure>
<p>如果集中包含通配符，则指定与目录名匹配，而不与文件名匹配。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOR /R [[drive:]path] %variable IN (<span class="built_in">set</span>) DO <span class="built_in">command</span> [<span class="built_in">command</span>-parameters]</span><br></pre></td></tr></table></figure>
<p>检查以<code>[drive:]path</code> 为根的目录树，指向每个目录中的 <code>FOR</code> 语句。<br>如果在 <code>/R</code> 后没有指定目录规范，则使用当前目录。如果集仅为一个单点<code>(.)</code>字符，则枚举该目录树。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOR /L %variable IN (start,step,end) DO <span class="built_in">command</span> [<span class="built_in">command</span>-parameters]</span><br></pre></td></tr></table></figure>
<p>该集表示以增量形式从开始到结束的一个数字序列。因此，<code>(1,1,5)</code> 将产生序列 <code>1 2 3 4 5</code>，<code>(5,-1,1)</code> 将产生序列<code>(5 4 3 2 1)</code> 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOR /F [<span class="string">"options"</span>] %variable IN (file-set) DO <span class="built_in">command</span> [<span class="built_in">command</span>-parameters]</span><br><span class="line">FOR /F [<span class="string">"options"</span>] %variable IN (<span class="string">"string"</span>) DO <span class="built_in">command</span> [<span class="built_in">command</span>-parameters]</span><br><span class="line">FOR /F [<span class="string">"options"</span>] %variable IN (<span class="string">'command'</span>) DO <span class="built_in">command</span> [<span class="built_in">command</span>-parameters]</span><br></pre></td></tr></table></figure>
<p>或者，如果有 <code>usebackq</code> 选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOR &#x2F;F [&quot;options&quot;] %variable IN (file-set) DO command [command-parameters]</span><br><span class="line">FOR &#x2F;F [&quot;options&quot;] %variable IN (&quot;string&quot;) DO command [command-parameters]</span><br><span class="line">FOR &#x2F;F [&quot;options&quot;] %variable IN (&#39;command&#39;) DO command [command-parameters]</span><br></pre></td></tr></table></figure>
<p><code>fileset</code> 为一个或多个文件名。继续到 <code>fileset</code> 中的下一个文件之前，每份文件都被打开、读取并经过处理。处理包括读取文件，将其分成一行行的文字，然后将每行解析成零或更多的符号。然后用已找到的符号字符串变量值调用 <code>For</code> 循环。    以默认方式，<code>/F</code> 通过每个文件的每一行中分开的第一个空白符号。跳过空白行。你可通过指定可选 <code>&quot;options&quot;</code> 参数替代默认解析操作。这个带引号的字符串包括一个或多个指定不同解析选项的关键字。这些关键字为:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>eol=c</code></td>
<td>指一个行注释字符的结尾(就一个)</td>
</tr>
<tr>
<td><code>skip=n</code></td>
<td>指在文件开始时忽略的行数。</td>
</tr>
<tr>
<td><code>delims=xxx</code></td>
<td>指分隔符集。这个替换了空格和制表符的默认分隔符集。</td>
</tr>
<tr>
<td><code>tokens=x,y,m-n</code></td>
<td>指每行的哪一个符号被传递到每个迭代的 <code>for</code> 本身。这会导致额外变量名称的分配。<code>m-n</code>格式为一个范围。通过 <code>nth</code> 符号指定 <code>mth</code>。如果符号字符串中的最后一个字符星号，那么额外的变量将在最后一个符号解析之后分配并接受行的保留文本。</td>
</tr>
<tr>
<td><code>usebackq</code></td>
<td>指定新语法已在下类情况中使用:在作为命令执行一个后引号的字符串并且一个单引号字符为文字字符串命令并允许在 <code>file-set</code>中使用双引号扩起文件名称。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注：</strong></p>
<ol>
<li><p>在批处理程序中使用 <code>FOR</code> 命令时，指定变量请使用 <code>%%variable</code> ，而不要用 <code>%variable</code>。变量名称是区分大小写的，所以 <code>%i</code> 不同于 <code>%I</code>。</p>
</li>
<li><p><code>FOR</code> 变量是单一字母、分大小写和全局的变量；    而且，不能同时使用超过 <code>52</code> 个。</p>
</li>
<li><p>对于带有空格的文件    名，你需要用双引号将文件名括起来。为了用这种方式来使</p>
<pre><code> 用双引号，还需要使用 `usebackq` 选项，否则，双引号会被理解成是用作定义某个要分析的字符串的。
</code></pre></li>
</ol>
<h3 id="amp-、-amp-amp-和"><a href="#amp-、-amp-amp-和" class="headerlink" title="&amp; 、&amp;&amp; 和 ||"></a>&amp; 、&amp;&amp; 和 ||</h3><p><code>&amp;</code> 顺序执行多条命令，而不管命令是否执行成功。</p>
<p><code>&amp;&amp;</code> 顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令。</p>
<p><code>||</code> 顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令。</p>
<h2 id="管道操作"><a href="#管道操作" class="headerlink" title="管道操作"></a>管道操作</h2><h3 id><a href="#" class="headerlink" title="|"></a>|</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir *.* &#x2F;s&#x2F;a | find &#x2F;c &quot;&quot;.exe&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>管道命令表示先执行 <code>dir</code>命令，对其输出的结果执行后面的 <code>find</code> 命令。命令行结果：输出当前文件夹及所有子文件夹里的 <code>.exe</code> 文件的个数。</p>
<h3 id="和-gt-gt"><a href="#和-gt-gt" class="headerlink" title="> 和 &gt;&gt;"></a>> 和 &gt;&gt;</h3><p><code>&gt;</code>  清除文件中原有的内容后再写入。</p>
<p><code>&gt;&gt;</code> 追加内容到文件末尾，而不会清除原有的内容。<br>主要将本来显示在屏幕上的内容输出到指定文件中，指定文件如果不存在，则自动生成该文件。</p>
<h2 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h2><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>启动一个单独的窗口以运行指定的程序或命令。</p>
<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>从批处理程序调用另一个批处理程序。</p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%0</code></td>
<td>批处理文件本身</td>
</tr>
<tr>
<td><code>%1</code></td>
<td>第一个参数</td>
</tr>
<tr>
<td><code>%9</code></td>
<td>第九个参数</td>
</tr>
<tr>
<td><code>%*</code></td>
<td>从第一个参数开始的所有参数</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/19/Clang%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李太吉">
      <meta itemprop="description" content="NPUer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李太吉的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/19/Clang%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">Clang教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-19 17:06:35 / 修改时间：18:58:42" itemprop="dateCreated datePublished" datetime="2020-07-19T17:06:35+08:00">2020-07-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h1><p><code>LLVM</code> 是 <code>Low Level Virtual Machine</code> （低级虚拟机）的首字母缩写， <code>LLVM</code> 发展至今已不再是“低级”虚拟机了，而是一个编译器的基础设施系统框架，提供程序分析、代码优化、机器代码生成等功能。</p>
<h2 id="LLVM-工具链"><a href="#LLVM-工具链" class="headerlink" title="LLVM 工具链"></a>LLVM 工具链</h2><p><code>LLVM</code> 有专门的文件格式 <code>.ll</code>（可读的 <code>LLVM</code> 字节码文件）、 <code>.bc</code>（可读的 <code>LLVM</code> 字节码文件），同时<code>LLVM</code> 也有其他的配套工具链用于编译、优化、链接等。<code>.bc</code> 文件比 <code>.ll</code> 文件多进行了汇编阶段，因此我们可以通过反汇编 <code>.bc</code> 文件得到 <code>.ll</code> 文件。下面我们已 <code>main.cpp</code> 和 <code>fib.cpp</code> 为例介绍 <code>LLVM</code> 工具链。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fib.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result = f0 + f1;</span><br><span class="line">        f0 = f1;</span><br><span class="line">        f1 = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please enter the order number: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The %dth Fibonacci number: %lld\n"</span>, n, fib(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="llvm-as"><a href="#llvm-as" class="headerlink" title="llvm-as"></a>llvm-as</h3><p>将 <code>.ll</code> 文件反汇编为 <code>bc</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-as main.ll -o main.bc</span><br></pre></td></tr></table></figure>
<h3 id="llvm-dis"><a href="#llvm-dis" class="headerlink" title="llvm-dis"></a>llvm-dis</h3><p>将 <code>.bc</code> 文件反汇编为 <code>.ll</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-dis main.bc -o main.ll</span><br></pre></td></tr></table></figure>
<h3 id="llvm-link"><a href="#llvm-link" class="headerlink" title="llvm-link"></a>llvm-link</h3><p>传统的编译器一般是对 <code>obj</code> 文件进行链接，<code>LLVM</code> 也可以对 <code>.ll</code> 和 <code>.bc</code> 文件（以下统称 <code>LLVM</code> 字节码文件）进行链接。</p>
<p><code>llvm-link</code> 接受 <code>.ll</code> 和 <code>.bc</code> 文件，进行链接并可输出 <code>.ll</code> 和 <code>.bc</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">llvm-link main.ll fib.ll -S -o linked.ll</span><br><span class="line">llvm-link main.bc fib.bc -o linked.bc</span><br></pre></td></tr></table></figure>
<h3 id="lli"><a href="#lli" class="headerlink" title="lli"></a>lli</h3><p><code>LLVM</code> 可以直接运行 <code>.ll</code> 和 <code>.bc</code> 文件。</p>
<p><code>lli</code> 执行 <code>.ll</code> 和 <code>.bc</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lli linked.ll</span><br><span class="line">lli linked.bc</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong><code>lli</code> 工具使用 <code>JIT</code> （即时编译）作为执行 <code>LLVM</code> 字节码文件的默认方法，若你的源码中包含对库函数或其他外部函数的调用，<code>lli</code> 运行时一般会出错。因为正常编译时，链接器会处理这些调用的外部函数，而 <code>LLVM</code> 字节码文件尚未经过链接，这些外部函数在 <code>LLVM</code> 字节码文件中只是一些符号，直接通过 <code>lli</code> 运行会出现未定义错误。</p>
<h3 id="llc"><a href="#llc" class="headerlink" title="llc"></a>llc</h3><p><code>LLVM</code> 可以将 <code>.ll</code> 和 <code>.bc</code> 文件编译为通用汇编语言。</p>
<p><code>llc</code> 编译 <code>LLVM</code> 源文件到用于指定的体系结构的汇编语言：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc main.ll -o main.s</span><br></pre></td></tr></table></figure>
<h3 id="opt"><a href="#opt" class="headerlink" title="opt"></a>opt</h3><p><code>LLVM</code> 还可以对 <code>.ll</code> 和 <code>.bc</code> 进行优化，<code>LLVM</code> 的优化能力也是<code>LLVM</code> 的一项突出能力。</p>
<p><strong>注：</strong></p>
<ol>
<li><p>当使用 <code>-O0</code> 编译（默认即是 <code>-O0</code> ）时，<code>Clang</code> 向每个函数添加 <code>optnone</code> 属性，这阻止了以后的进一步优化，为了防止这种情况，可以添加 <code>-Xclang -disable-O0-optnone</code> 选项。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ fib.cpp -Xclang -disable-O0-optnone -emit-llvm -S -o fib.ll</span><br></pre></td></tr></table></figure>
</li>
<li><p>当希望进行调试时，最好使用 <code>-O0</code> 或 <code>-O1</code> 编译，因为优化可能会改变控制流，导致指令执行顺序发生变化；还可能直接将一些潜在的 <code>bug</code> 优化掉（尽管 <code>bug</code> 没有了，但这是编译器优化解决的，不代表代码正确，你甚至不知道 <code>bug</code> 的存在，当你更换编译选项或者编译器时，<code>bug</code> 就又出现了）。</p>
</li>
<li><p>越高的优化级别生成的代码一般执行速度更快，但代码大小也普遍更大。</p>
</li>
<li><p><code>clang</code> 是一个驱动程序，给 <code>clang</code> 传入优化选项实质是传给了 <code>opt</code> 。</p>
</li>
</ol>
<p><code>opt</code> 可以对 <code>.ll</code> 和 <code>.bc</code> 文件进行优化，<code>opt</code> 可以接受的优化选项很多，这里不再赘述。<code>opt</code> 还可以生成控制流图（<code>Control Flow Graphic</code> ）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; clang++ fib.cpp -emit-llvm -fno-discard-value-names -S -o fib.ll</span><br><span class="line">&gt; opt -analyze -dot-cfg-only fib.ll</span><br><span class="line">Writing &#39;._Z3fibi.dot&#39;...</span><br><span class="line">Printing analysis &#39;Print CFG of function to &#39;dot&#39; file (with no function bodies)&#39; for function &#39;_Z3fibi&#39;:</span><br></pre></td></tr></table></figure>
<p>你会得到一些 <code>.dot</code> 文件，你需要配置 <code>Graphviz</code> ，执行 <code>dot  ._Z3fibi.dot -Tpng -o fib.png</code> 。</p>
<p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/fib.jpg" alt="cfg" style="zoom: 80%;"></p>
<p><code>opt</code> 还支持以下的可视化图形帮助理解分析逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--view-callgraph                                  - View call graph</span><br><span class="line">--view-cfg                                        - View CFG of function</span><br><span class="line">--view-cfg-only                                   - View CFG of function (with no function bodies)</span><br><span class="line">--view-dom                                        - View dominance tree of function</span><br><span class="line">--view-dom-only                                   - View dominance tree of function (with no function bodies)</span><br><span class="line">--view-postdom                                    - View postdominance tree of function</span><br><span class="line">--view-postdom-only                               - View postdominance tree of function (with no function bodies)</span><br><span class="line">--view-regions                                    - View regions of function</span><br><span class="line">--view-regions-only                               - View regions of function (with no function bodies)</span><br></pre></td></tr></table></figure>
<p><code>opt</code> 可以根据硬件平台的不同执行不同的优化，可以参看<a href="https://www.zhihu.com/question/31379945/answer/51755394" target="_blank" rel="noopener">编译器优化做指令调度时是怎么考虑不同的微架构下对同一个指令的执行周期数是不同的？ - RednaxelaFX的回答 - 知乎</a>以及使用<a href="https://stackoverflow.com/questions/15036909/clang-how-to-list-supported-target-architectures" target="_blank" rel="noopener">clang: how to list supported target architectures?</a>查看 <code>LLVM</code> 支持的平台和 <code>CPU</code> 。</p>
<h3 id="lld"><a href="#lld" class="headerlink" title="lld"></a>lld</h3><p><code>LLVM</code> 拥有配套的链接器 <code>LLD</code>，可以进行链接时优化（<code>Link Time Optimization</code> ），而且相对于 <code>GNU ld</code> ，链接速度更快，编译输出更小，具体请查看<a href="http://lld.llvm.org/" target="_blank" rel="noopener"> <code>LLD</code> 官网</a>。</p>
<p>可以在编译时添加 <code>-fuse-ld=lld</code> 选项来指定  <code>LLD</code> 链接器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ main.cpp -fuse-ld&#x3D;lld -o main.exe</span><br></pre></td></tr></table></figure>
<p><code>LLVM</code> 通过 <code>LLVM IR</code> 来实现 <code>LTO</code>，如果想使用 <code>LTO</code> ，需要在编译每个待链接的文件以及链接这些文件时都添加 <code>-flto</code> 选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang++ main.cpp -flto -O1 -c -o main.o</span><br><span class="line">clang++ factorial.bc -flto -O1 -c -o factorial.o</span><br><span class="line">clang++ mian.o factorial.o -flto -fuse-ld&#x3D;lld -o main.exe</span><br></pre></td></tr></table></figure>
<p>关于 <code>LTO</code> ，可以查看官网上 <a href="https://llvm.org/docs/LinkTimeOptimization.html" target="_blank" rel="noopener"><code>LLVM LTO</code> </a> 的介绍，以及 <code>GCC</code><a href="https://stackoverflow.com/questions/48030706/can-lto-for-gcc-or-clang-optimize-across-c-and-c-methods" target="_blank" rel="noopener"> <code>LTO</code></a>的介绍。</p>
<p><strong>注意：</strong></p>
<ol>
<li><code>Clang</code> 和 <code>GCC</code> 都支持 <code>LTO</code>，但由于 <code>LTO</code> 是通过中间表示（<code>GCC</code> 上为 <code>GIMPLE</code> ，<code>Clang</code>上为 <code>LLVM IR</code> ）实现的，所以不能 <code>Clang</code> 和 <code>GCC</code> 的 <code>LTO</code> 不通用。</li>
<li>若要使用 <code>LTO</code> ，建议使用相同的选项编译参与链接的所有文件，且必须在编译和链接时添加选项 <code>-flto</code> 。但优化标志 <code>-Og</code> 、<code>-O2</code> 和 <code>-Os</code> 可以作为优化属性传递，而不会受限于编译时和链接时间标志应该相同的情况。</li>
<li>在链接时传递的优化和目标选项将被忽略。</li>
<li>有时需要在编译 <code>.obj</code> 文件时添加 <code>-O1</code> 等优化选项，才会启用 <code>LTO</code> 。</li>
</ol>
<h3 id="lldb"><a href="#lldb" class="headerlink" title="lldb"></a>lldb</h3><p><code>LLVM</code> 也有对应的调试器 <code>LLDB</code>，<code>LLDB</code> 与 <code>GDB</code> 功能类似，但命令更加友好，而且<code>LLDB</code> 具有与 <code>Clang</code> 相同的有点，也就是它可以高亮显示调试和错误信息。可以登录<a href="https://lldb.llvm.org" target="_blank" rel="noopener"> <code>LLDB</code> 官网</a>，学习<code>LLDB</code>  的<a href="https://lldb.llvm.org/use/tutorial.html" target="_blank" rel="noopener">教程</a>，以及查看 <code>LLDB</code> 与 <code>GDB</code> 命令的<a href="https://lldb.llvm.org/use/map.html" target="_blank" rel="noopener">对照</a>，你也可以首先学习 <code>GDB</code> 的教程 <a href="http://www.unknownroad.com/rtfm/gdbtut/" target="_blank" rel="noopener">RMS’s gdb Debugger Tutorial</a>。</p>
<h2 id="LLVM-IR-文件的布局"><a href="#LLVM-IR-文件的布局" class="headerlink" title="LLVM IR 文件的布局"></a>LLVM IR 文件的布局</h2><h3 id="Target-Information"><a href="#Target-Information" class="headerlink" title="Target Information"></a>Target Information</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID &#x3D; &#39;main.cpp&#39;</span><br><span class="line">source_filename &#x3D; &quot;main.cpp&quot;</span><br><span class="line">target datalayout &#x3D; &quot;e-m:w-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple &#x3D; &quot;x86_64-w64-windows-gnu&quot;</span><br></pre></td></tr></table></figure>
<p><code>target datalayout</code> 为 <code>target</code> 的数据布局，<code>target triple</code> 为 <code>target</code> 的平台信息。</p>
<p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/target.jpg" alt="target"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i64:64 &#x2F;&#x2F; 指定支持的整型的对齐单位，这里即是指支持64bit的整型，且以64bit对齐（存储整型的起始地址必须是128的倍数）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f80:128 &#x2F;&#x2F; 指定支持的浮点类型的对齐单位，这里即是指支持80bit的浮点类型，但是以128bit对齐（存储浮点数的起始地址必须是128的倍数）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n8:16:32:64 &#x2F;&#x2F; 指定一组支持的以位为单位的整数类型</span><br></pre></td></tr></table></figure>
<p>其他具体信息，参看<a href="https://llvm.org/docs/LangRef.html#data-layout" target="_blank" rel="noopener">datalayout</a>。</p>
<p>我的<code>target triple</code> 为 <code>&quot;x86_64-w64-windows-gnu&quot;</code>，即 <code>Windows</code> <code>x64</code> 操作系统上以 <code>MinGW</code> 为运行时环境（一般 <code>Windows</code> 系统上以 <code>MSVC</code> 为运行时环境， <code>Windows</code> 系统和 <code>GCC</code> 搭配来使用 <code>LLVM</code> 较为麻烦，但我觉得 <code>MSVC</code> 实在是太臃肿了。不过电脑配置如果满足要求，还是建议在 <code>Windows</code> 系统上使用 <code>MSVC</code>，因为许多软件在 <code>Windows</code> 系统上支持甚至唯一支持 <code>MSVC</code> 。使用 <code>MSVC</code>不仅省去了不少麻烦，而且 <code>Windows</code> 开发人员早晚跳不过 <code>Visual Studio</code> 。）。</p>
<p>可以通过 <code>clang -v</code> 查看 <code>Clang</code> 的版本和 <code>target</code> 信息，例如我的<code>Clang</code>具体信息为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clang version 9.0.0 (tags&#x2F;RELEASE_900&#x2F;final)</span><br><span class="line">Target: x86_64-w64-windows-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">InstalledDir: D:\LLVM\bin</span><br></pre></td></tr></table></figure>
<p><code>Clang</code> 编译时可以通过<code>--target</code> 选项指定编译的目标平台，从而实现交叉编译，当然你需要有对应的运行时库（也就是说，假如你在 <code>Linux</code> 平台上下载了 <code>MSVC</code> 的运行时库，你就可以在  <code>Linux</code> 平台上编译 <code>MSVC</code> 支持的程序）。还可以将不同语言编译到 <code>LLVM IR</code> 层面进行链接，实现多语言的相互调用。这是 <code>LLVM</code> 非常大的一个优势，借助于 <code>LLVM IR</code>，<code>LLVM</code> 实现了平台独立性和灵活性。</p>
<p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/crosscompile.jpg" alt="crosscompile"></p>
<p><code>Clang</code> 支持下列 <code>target triple</code>的组合，具体可以查看<code>Clang</code> 的<a href="http://clang.llvm.org/docs/CrossCompilation.html" target="_blank" rel="noopener">文档</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The triple has the general format &lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;, where:</span><br><span class="line">arch &#x3D; x86, arm, thumb, mips, etc.</span><br><span class="line">sub &#x3D; for ex. on ARM: v5, v6m, v7a, v7m, etc.</span><br><span class="line">vendor &#x3D; pc, apple, nvidia, ibm, etc.</span><br><span class="line">sys &#x3D; none, linux, win32, darwin, cuda, etc.</span><br><span class="line">abi &#x3D; eabi, gnu, android, macho, elf, etc.</span><br></pre></td></tr></table></figure>
<p>常用的 <code>target triple</code> 有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi</span><br><span class="line">armv7a-none-eabi</span><br><span class="line">arm-linux-gnueabihf </span><br><span class="line">arm-none-linux-gnueabi</span><br><span class="line">i386-pc-linux-gnu </span><br><span class="line">x86_64-apple-darwin10</span><br><span class="line">i686-w64-windows-gnu # same as i686-w64-mingw32</span><br><span class="line">x86_64-pc-linux-gnu # from ubuntu 64 bit</span><br><span class="line">x86_64-unknown-windows-cygnus # cygwin 64-bit</span><br><span class="line">x86_64-w64-windows-gnu # same as x86_64-w64-mingw32</span><br><span class="line">i686-pc-windows-gnu # MSVC</span><br><span class="line">x86_64-pc-windows-gnu # MSVC 64-BIT</span><br></pre></td></tr></table></figure>
<h3 id="LLVM-IR-文件的架构"><a href="#LLVM-IR-文件的架构" class="headerlink" title="LLVM IR 文件的架构"></a>LLVM IR 文件的架构</h3><p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/layout.jpg" alt="layout"></p>
<p><code>LLVM IR</code> 文件从高到低由 <code>Moudle</code> 、<code>Function</code> 、 <code>Basic Block</code> 和 <code>Instruction</code>四个层次组成。</p>
<h2 id="SSA-（静态单分配）"><a href="#SSA-（静态单分配）" class="headerlink" title="SSA （静态单分配）"></a>SSA （静态单分配）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p><code>SSA</code> 形式是指程序中的每个变量必须且只能在定义时初始化。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; 10;</span><br><span class="line">int y &#x3D; 20; &#x2F;&#x2F; SSA</span><br><span class="line"></span><br><span class="line">int x;</span><br><span class="line">x &#x3D; 10; &#x2F;&#x2F; Not SSA</span><br></pre></td></tr></table></figure>
<p>编译器为了进行代码优化，会对变量的定义和使用进行分析，主要有两种：</p>
<ul>
<li><p>使用-定义链（ <code>Use-­Definition (UD) Chains</code> )：</p>
<blockquote>
<p>对于给定的变量 <code>x</code> 的定义，它的所有使用是什么？</p>
</blockquote>
</li>
<li><p>定义-使用链（ <code>­Definition-Use (UD) Chains</code> )：</p>
<blockquote>
<p>对于给定的变量 <code>x</code> 的使用，它的所有可达性定义是什么？</p>
</blockquote>
</li>
</ul>
<p>不幸的是，<code>UD</code> 和 <code>DU</code> 检查的花费可能会非常昂贵。</p>
<p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/check.jpg" alt="check" style="zoom: 80%;"></p>
<p>这是由于 <code>x</code> 可以重复赋值（也即重定义）导致的，自然地，我们可以想到让每个变量只能定义一次（可以类比 <code>Java</code> 中的 <code>static final</code> 常量，但略有不同，<code>Java</code> 中的 <code>static final</code> 常量可以延迟赋值，把赋值语句放在 <code>static</code> 块中）。</p>
<p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/ssa.jpg" alt="ssa" style="zoom:50%;"></p>
<p>但 <code>SSA</code> 在处理控制流分支时存在一个问题：</p>
<p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/ssacontrol.jpg" alt="ssacontrol" style="zoom: 67%;"></p>
<p>变量每次赋值在 <code>SSA</code> 中都成为了一个新的变量，在线性运行时没有问题，但在遇到分支时就无法判断要使用那个新变量了。我们需要$\Phi$ 节点来实现控制流。</p>
<h4 id="Phi-函数"><a href="#Phi-函数" class="headerlink" title="$\Phi$ 函数"></a>$\Phi$ 函数</h4><blockquote>
<p>$\Phi$ 函数将各个控制流分支路径上的定义合并为一个单一的定义</p>
</blockquote>
<p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/merge.jpg" alt="merge" style="zoom: 67%;"></p>
<p>传统指令集并不支持 $\Phi$ 函数（即 <code>LLVM IR</code> 中的 <code>phi</code> 指令）的概念，<code>LLVM</code> 会对 <code>phi</code> 指令进行 <code>Phi destruction</code> ，将 <code>phi</code> 指令变为底层支持的汇编命令，例如我们可以通过在各个控制流分支路径上插入语句定义一个共享变量来实现 $\Phi$ 节点，也可以将因赋值而新定义的变量分配到同一个寄存器，从而实现在 <code>LLVM IR</code> 层次上保持 <code>SSA</code> 形式，而在寄存器层次上实质为同一变量。可以阅读<a href="https://www.zhihu.com/question/49642237/answer/117428698" target="_blank" rel="noopener">llvm的reg2mem pass做了哪些事情？ - 蓝色的回答 - 知乎</a>。</p>
<p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/implement.jpg" alt="implement" style="zoom: 67%;"></p>
<p><strong>初级 SSA</strong></p>
<ul>
<li><p>每个赋值都会生成一个新的变量。</p>
</li>
<li><p>在每个插入点为所有分支中的新变量插入 $\Phi$ 节点。</p>
</li>
</ul>
<p><strong>最小化 SSA</strong></p>
<ul>
<li><p>每个赋值都会生成一个新的变量。</p>
</li>
<li><p>在每个插入点为处于活跃期的分支中的新变量插入 $\Phi$ 节点。活跃期定义是从变量第一次被定义（赋值）开始，到它下一次被赋值前的最后一次被使用为止。</p>
</li>
</ul>
<h5 id="什么时候插入-Phi-函数"><a href="#什么时候插入-Phi-函数" class="headerlink" title="什么时候插入 $\Phi$ 函数"></a>什么时候插入 $\Phi$ 函数</h5><p>对于变量 <code>x</code> ，我们当且仅当以下情况时在 <code>Z</code> 中插入 $\Phi$ 函数：</p>
<p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/cfg.png" alt="cfg" style="zoom: 67%;"></p>
<ul>
<li><p>变量 <code>x</code> 在各个分支（ <code>if.then</code>、 <code>if.else</code>）总共定义了多于一次。</p>
</li>
<li><p>变量 <code>x</code> 新定义所在的块都可以到达块 <code>Z</code> ，且块 <code>Z</code> 是变量 <code>x</code> 新定义所在块的最先公共后继。</p>
</li>
</ul>
<p>可以应用 <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s14/public/lectures/L13-SSA-Concepts-1up.pdf" target="_blank" rel="noopener"> <code>Lengauer-Tarjan</code> </a>算法计算支配树和支配边界判断插入 $\Phi$ 函数的块，关于支配树和支配边界还可以阅读<a href="https://blog.csdn.net/dashuniuniu/article/details/52224882" target="_blank" rel="noopener">构造Dominator Tree以及Dominator Frontier</a>。</p>
<h3 id="SSA-在编译优化中的作用"><a href="#SSA-在编译优化中的作用" class="headerlink" title="SSA 在编译优化中的作用"></a>SSA 在编译优化中的作用</h3><ul>
<li><p>常量传播（ <code>constant propagation</code> ）</p>
<blockquote>
<p>当 v $\leftarrow$ c 或 v $\leftarrow$ $\Phi$ (c, c, c) 时将  <code>v</code> 替换为 <code>c</code> ，并将 v $\leftarrow$  c 和 v $\leftarrow$ $\Phi$ (c, c, c) 语句删除。</p>
</blockquote>
</li>
<li><p>复写传播（ <code>copy propagation</code> ）</p>
<blockquote>
<p>当 x $\leftarrow$ y 或 x $\leftarrow$ $\Phi$ (y, y, y) 时将  <code>x</code> 替换为 <code>y</code> ，并将 x $\leftarrow$ y 和 x $\leftarrow$ $\Phi$ (y, y, y) 语句删除。</p>
</blockquote>
</li>
<li><p>常量折叠（ <code>constant folding</code> ）</p>
<blockquote>
<p>当 v $\leftarrow$ expression(c1, c2, …) 时可以将右值表达式计算出结果以替换右值表达式。</p>
</blockquote>
</li>
<li><p>无用代码消除（ <code>dead code elimination</code> ）</p>
<blockquote>
<ul>
<li><p>假设所有变量都是常量，直到该变量值改变。</p>
</li>
<li><p>假设所有基本块都无法执行，直到该块被执行。</p>
</li>
</ul>
<p>通过可达性分析，将常量进行折叠，并消除无用代码。</p>
</blockquote>
</li>
</ul>
<h3 id="SSA-参看书目"><a href="#SSA-参看书目" class="headerlink" title="SSA 参看书目"></a>SSA 参看书目</h3><ul>
<li><a href="http://link.zhihu.com/?target=http%3A//www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s16/www/">15-745 Optimizing Compilers for Modern Architectures, Spring 2016</a></li>
<li><a href="http://ssabook.gforge.inria.fr/latest/book.pdf" target="_blank" rel="noopener">Static Single Assignment Book</a></li>
</ul>
<h2 id="LLVM-IR-基本语法"><a href="#LLVM-IR-基本语法" class="headerlink" title="LLVM IR 基本语法"></a>LLVM IR 基本语法</h2><p>简要介绍 <code>LLVM IR</code> 的基本语法常用的指令，详细文档请参看<a href="https://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">LLVM Language Reference Manual</a>。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="comment">define dso_local i64 @_Z3fibi(i32 %n) #0 &#123;</span></span><br><span class="line"><span class="comment">entry:</span></span><br><span class="line"><span class="comment">  %retval = alloca i64, align 8</span></span><br><span class="line"><span class="comment">  %n.addr = alloca i32, align 4</span></span><br><span class="line"><span class="comment">  %result = alloca i64, align 8</span></span><br><span class="line"><span class="comment">  %f0 = alloca i64, align 8</span></span><br><span class="line"><span class="comment">  %f1 = alloca i64, align 8</span></span><br><span class="line"><span class="comment">  %i = alloca i32, align 4</span></span><br><span class="line"><span class="comment">  store i32 %n, i32* %n.addr, align 4</span></span><br><span class="line"><span class="comment">  %0 = load i32, i32* %n.addr, align 4</span></span><br><span class="line"><span class="comment">  %cmp = icmp slt i32 %0, 2</span></span><br><span class="line"><span class="comment">  br i1 %cmp, label %if.then, label %if.end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if.then:                                          ; preds = %entry</span></span><br><span class="line"><span class="comment">  %1 = load i32, i32* %n.addr, align 4</span></span><br><span class="line"><span class="comment">  %conv = sext i32 %1 to i64</span></span><br><span class="line"><span class="comment">  store i64 %conv, i64* %retval, align 8</span></span><br><span class="line"><span class="comment">  br label %return</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if.end:                                           ; preds = %entry</span></span><br><span class="line"><span class="comment">  store i64 0, i64* %result, align 8</span></span><br><span class="line"><span class="comment">  store i64 0, i64* %f0, align 8</span></span><br><span class="line"><span class="comment">  store i64 1, i64* %f1, align 8</span></span><br><span class="line"><span class="comment">  store i32 1, i32* %i, align 4</span></span><br><span class="line"><span class="comment">  br label %for.cond</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for.cond:                                         ; preds = %for.inc, %if.end</span></span><br><span class="line"><span class="comment">  %2 = load i32, i32* %i, align 4</span></span><br><span class="line"><span class="comment">  %3 = load i32, i32* %n.addr, align 4</span></span><br><span class="line"><span class="comment">  %cmp1 = icmp slt i32 %2, %3</span></span><br><span class="line"><span class="comment">  br i1 %cmp1, label %for.body, label %for.end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for.body:                                         ; preds = %for.cond</span></span><br><span class="line"><span class="comment">  %4 = load i64, i64* %f0, align 8</span></span><br><span class="line"><span class="comment">  %5 = load i64, i64* %f1, align 8</span></span><br><span class="line"><span class="comment">  %add = add nsw i64 %4, %5</span></span><br><span class="line"><span class="comment">  store i64 %add, i64* %result, align 8</span></span><br><span class="line"><span class="comment">  %6 = load i64, i64* %f1, align 8</span></span><br><span class="line"><span class="comment">  store i64 %6, i64* %f0, align 8</span></span><br><span class="line"><span class="comment">  %7 = load i64, i64* %result, align 8</span></span><br><span class="line"><span class="comment">  store i64 %7, i64* %f1, align 8</span></span><br><span class="line"><span class="comment">  br label %for.inc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for.inc:                                          ; preds = %for.body</span></span><br><span class="line"><span class="comment">  %8 = load i32, i32* %i, align 4</span></span><br><span class="line"><span class="comment">  %inc = add nsw i32 %8, 1</span></span><br><span class="line"><span class="comment">  store i32 %inc, i32* %i, align 4</span></span><br><span class="line"><span class="comment">  br label %for.cond</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for.end:                                          ; preds = %for.cond</span></span><br><span class="line"><span class="comment">  %9 = load i64, i64* %result, align 8</span></span><br><span class="line"><span class="comment">  store i64 %9, i64* %retval, align 8</span></span><br><span class="line"><span class="comment">  br label %return</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">return:                                           ; preds = %for.end, %if.then</span></span><br><span class="line"><span class="comment">  %10 = load i64, i64* %retval, align 8</span></span><br><span class="line"><span class="comment">  ret i64 %10</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p><code>;</code> 表示单行注释的开始。</p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p><code>LLVM IR</code> 中的标识符分为两种类型：全局的和局部的。全局的标识符包括函数名和全局变量，会加一个 <code>@</code> 前缀，局部的标识符会加一个 <code>%</code> 前缀。一般地，可用标识符对应的正则表达式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*</span><br></pre></td></tr></table></figure>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define dso_local i64 @_Z3fibi(i32 %n) #0</span><br></pre></td></tr></table></figure>
<p>定义了一个函数，其中 <code>i64</code> 代表 <code>64</code> 位整数，即 <code>C/C++</code> 中的 <code>int</code>；<code>@_Z3fibi</code> 是函数名且代表函数是全局的；括号内是参数列表。<code>#0</code> 是指向函数属性的标记符。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;elementnumber&gt; x &lt;elementtype&gt;]</span><br></pre></td></tr></table></figure>
<p>数据元素在内存中是连续存储的。对于索引超出静态类型所指定的数组末端没有限制（尽管在某些情况下对于索引超出已分配对象的边界有限制）。这意味着一维”可变大小数组“寻址可以在零长度数组类型的 <code>LLVM</code> 中实现。例如，<code>LLVM</code> 中 <code>pascal</code> 风格数组的实现可以使用 <code>{i32， [0 x float]}</code> 类型。</p>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%T1 &#x3D; type &#123; &lt;type list&gt; &#125;     ; Identified normal struct type</span><br><span class="line">%T2 &#x3D; type &lt;&#123; &lt;type list&gt; &#125;&gt;   ; Identified packed struct type</span><br></pre></td></tr></table></figure>
<p>结构类型用于表示内存中的数据成员集合。结构的元素可以是任何具有大小的类型。</p>
<p>通过使用 <code>getelementptr</code> 指令获得指向字段的指针，可以使用 <code>load</code> 和 <code>store</code> 访问内存中的结构。使用<code>extractvalue</code> 和 <code>insertvalue</code> 指令访问寄存器中的结构。</p>
<p>结构可以选择“打包”结构，这表示结构的对齐方式是一个字节，并且元素之间没有填充。在非打包结构中，字段类型之间的填充是由模块中的 <code>DataLayout</code> 字符串定义的，这是匹配底层代码生成器所期望的内容所必需的。</p>
<h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><h4 id="alloca"><a href="#alloca" class="headerlink" title="alloca"></a>alloca</h4><h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; &#x3D; alloca [inalloca] &lt;type&gt; [, &lt;ty&gt; &lt;NumElements&gt;] [, align &lt;alignment&gt;] [, addrspace(&lt;num&gt;)]     ; yields type addrspace(num)*:result</span><br></pre></td></tr></table></figure>
<p>返回一个指针。分配的内存是未初始化的，从未初始化的内存中加载会产生一个未定义的值。如果分配的堆栈空间不足，则操作本身未定义。</p>
<p><code>alloca</code> 指令也可以用来分配结构体。</p>
<h4 id="load"><a href="#load" class="headerlink" title="load"></a>load</h4><h5 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h5><p><code>load</code> 的语法较为复杂，具有多种形式，但常用的形式一般如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%0 &#x3D; load i32, i32* %n.addr, align 4 &#x2F;&#x2F; 从地址%n.addr中读取i32型数据</span><br></pre></td></tr></table></figure>
<h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><h5 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h5><p><code>store</code> 的语法较为复杂，具有多种形式，但常用的形式一般如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store i32 %n, i32* %n.addr, align 4 &#x2F;&#x2F; 向地址%n.addr中读取i32型数据%n</span><br></pre></td></tr></table></figure>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><h5 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; &#x3D; [tail | musttail | notail ] call [fast-math flags] [cconv] [ret attrs] [addrspace(&lt;num&gt;)]</span><br><span class="line">           &lt;ty&gt;|&lt;fnty&gt; &lt;fnptrval&gt;(&lt;function args&gt;) [fn attrs] [ operand bundles ]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%call2 &#x3D; call i64 @_Z3fibi(i32 %1) &#x2F;&#x2F; 调用fib函数，返回值赋给%call2</span><br></pre></td></tr></table></figure>
<h4 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h4><h5 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret &lt;type&gt; &lt;value&gt;       ; Return a value from a non-void function</span><br><span class="line">ret void                 ; Return from void function</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret i64 %10 &#x2F;&#x2F; 返回%10</span><br></pre></td></tr></table></figure>
<h4 id="br"><a href="#br" class="headerlink" title="br"></a>br</h4><h5 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">br i1 &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt;</span><br><span class="line">br label &lt;dest&gt;          ; Unconditional branch</span><br></pre></td></tr></table></figure>
<p>在执行条件 <code>br</code> 指令时，将对 <code>i1</code> 参数求值。如果该值为真，则控制流到 <code>iftrue</code> 标签参数。如果 <code>cond</code> 为假，则控制流到 <code>iffalse</code> 标签参数。<code>br</code> 指令的无条件形式以单个 <code>label</code> 值为目标。</p>
<h4 id="phi"><a href="#phi" class="headerlink" title="phi"></a>phi</h4><h5 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; &#x3D; phi [fast-math-flags] &lt;ty&gt; [ &lt;val0&gt;, &lt;label0&gt;], ...</span><br></pre></td></tr></table></figure>
<p><code>phi</code> 指令在逻辑上接受在当前块之前执行的前任基本块对应所指定的值。</p>
<p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/phi.jpg" alt="phi"></p>
<p><code>phi</code> 指令主要用来解决 <code>SSA</code> （静态单赋值）带来的问题。不过 <code>SSA</code> 带来的变量不能重复赋值问题也能通过指针来解决，可以向一个不变的地址上多次执行 <code>store</code> 指令从而实现多次赋值。</p>
<p>要想在 <code>LLVM IR</code> 中使用 <code>phi</code> 指令，可以应用 <code>-mem2reg</code> 优化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang++ fib.cpp -Xclang -disable-O0-optnone -emit-llvm -S -o fib.ll </span><br><span class="line">opt -mem2reg -S fib.ll -o fib-opt.ll</span><br></pre></td></tr></table></figure>
<p>注意仍然要添加 <code>-Xclang -disable-O0-optnone</code> 编译。</p>
<p>同理要想在 <code>LLVM IR</code> 中屏蔽 <code>phi</code> 指令，可以应用 <code>-reg2mem</code> 优化（默认情况下即使不使用 <code>phi</code> 指令）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang++ fib.cpp -Xclang -disable-O0-optnone -emit-llvm -S -o fib.ll </span><br><span class="line">opt -reg2mem -S fib.ll -o fib-opt.ll</span><br></pre></td></tr></table></figure>
<h4 id="getelementptr-GEP"><a href="#getelementptr-GEP" class="headerlink" title="getelementptr (GEP)"></a>getelementptr (GEP)</h4><h5 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; &#x3D; getelementptr &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;&#123;, [inrange] &lt;ty&gt; &lt;idx&gt;&#125;*</span><br><span class="line">&lt;result&gt; &#x3D; getelementptr inbounds &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;&#123;, [inrange] &lt;ty&gt; &lt;idx&gt;&#125;*</span><br><span class="line">&lt;result&gt; &#x3D; getelementptr &lt;ty&gt;, &lt;ptr vector&gt; &lt;ptrval&gt;, [inrange] &lt;vector index type&gt; &lt;idx&gt;</span><br></pre></td></tr></table></figure>
<p>第一个<code>ty</code>是第一个索引使用的基本类型，第二个 <code>ty</code> 表示其后的基址<code>ptrval</code>的类型。<code>&lt;ty&gt; &lt;idx&gt;</code> 是第一组索引的类型和值，<code>&lt;ty&gt; &lt;idx&gt;</code>可以出现多次，其后出现的就是第二组、第三组等等索引的类型和值。要注意索引的类型和索引使用的基本类型是不一样的，索引的类型一般为<code>i32</code>或<code>i64</code>，而索引使用的基本类型确定的是增加索引值时指针的偏移量。</p>
<h5 id="理解第一个索引"><a href="#理解第一个索引" class="headerlink" title="理解第一个索引"></a>理解第一个索引</h5><ol>
<li>第一个索引不会改变返回的指针的类型，也就是说 <code>ptrval</code> 前面的 <code>*</code> 对应什么类型，返回就是什么类型</li>
<li>第一个索引的偏移量的是由第一个索引的值和第一个 <code>ty</code> 指定的基本类型共同确定的。</li>
</ol>
<p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/gep1.jpg" alt="gep1"></p>
<p>上图中第一个索引所使用的基本类型是 <code>[6 x i8]</code>，值是1，所以返回的值相对基址 <code>@a_gv</code> 前进了 <code>6</code> 个字节。由于只有一个索引，所以返回的指针也是 <code>[6 x i8]*</code> 类型。</p>
<h5 id="理解后面的索引"><a href="#理解后面的索引" class="headerlink" title="理解后面的索引"></a>理解后面的索引</h5><ol>
<li><p>后面的索引是在 <code>Aggregate Types</code> 内进行索引。</p>
</li>
<li><p>每增加一个索引，就会使得该索引使用的基本类型和返回的指针的类型去掉一层。</p>
</li>
</ol>
<p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/gep2.jpg" alt="gep2"></p>
<p>我们看 <code>%elem_ptr = getelementptr [6 x i8], [6 x i8]* @a_gv, i32 0, i32 0</code> 这一句，第一个索引值是 <code>0</code>，使用的基本类型 <code>[6 x i8]</code> , 因此其使返回的指针先前进 <code>0 x 6</code> 个字节，也就是不前进，第二个索引的值是 <code>1</code>，使用的基本类型就是 <code>i8</code>（ <code>[6 x i8]</code>去掉左边的 <code>6</code> ），因此其使返回的指针前进一个字节，返回的指针类型为 <code>i8*</code>（ <code>[6 x i8]*</code>去掉左边的 <code>6</code> ）。</p>
<h5 id="GEP如何作用于结构体"><a href="#GEP如何作用于结构体" class="headerlink" title="GEP如何作用于结构体"></a>GEP如何作用于结构体</h5><p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/gep3.jpg" alt="gep3"></p>
<p>只有一个索引情况下， <code>GEP</code> 作用于结构体与作用于数组的规则相同，<code>%new_ptr = getelementptr %MyStruct*, %MyStruct* @a_gv, i32 1</code>使得 <code>%new_ptr</code> 相对 <code>@a_gv</code> 偏移一个结构体 <code>%MyStruct</code> 的大小。</p>
<p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/gep4.jpg" alt="gep4"></p>
<p>在有两个索引的情况下，第二个索引对返回指针的影响跟结构体的成员类型有关。譬如说在上图中，第二个索引值是 <code>1</code>，那么返回的指针就会偏移到第二个成员，也就是偏移 <code>1</code> 个字节，由于第二个成员是 <code>i32</code> 类型，因此返回的指针是 <code>i32*</code> 。</p>
<p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/gep5.jpg" alt="gep5"></p>
<p>如果结构体的本身也有 <code>Aggregate Type</code> 的成员，就会出现超过两个索引的情况。第三个索引将会进入这个<code>Aggregate  Type</code> 成员进行索引。譬如说上图中的第二个索引是 <code>2</code> ，指针先指向第三个成员，第三个成员是个数组。再看第三个索引是 <code>0</code> ，因此指针就指向该成员的第一个元素，指针类型也变成了 <code>i32*</code> 。</p>
<p><strong>注：</strong> 本 <code>GEP</code> 小节引用了知乎用户<a href="https://www.zhihu.com/people/guo-ai-54" target="_blank" rel="noopener">@ZRN-BF</a>的文章<a href="https://zhuanlan.zhihu.com/p/66909226" target="_blank" rel="noopener">A Tour to LLVM IR（下）</a>。</p>
<h2 id="Clang-介绍"><a href="#Clang-介绍" class="headerlink" title="Clang 介绍"></a>Clang 介绍</h2><p>上文已经提到 <code>Clang</code>只是前端的一个 <code>Driver</code> ，从编译器架构上来说，<code>Clang</code> 只是用来进行词法分析、语法分析、语义分析、中间代码生成的编译器前端。 <code>Clang</code> 需要借助其他编译器后端来实现机器代码生成。这也是<code>Clang</code> 的 <code>Target Information</code> 的作用。 <code>Windows</code> 上 <code>Clang</code> 可以与 <code>MSVC</code> 或 <code>MinGW</code> 搭配起来构成一个完整的编译器。</p>
<p><code>Clang</code> 生成中间代码（也就是 <code>LLVM</code> 字节码），并在此基础上进行一系列优化操作，再进一步生成可执行文件。由于 <code>Clang</code> 需要和其他的编译器后端组合，所以在编程源码时就会出现许多由于前后端不搭配导致的问题。</p>
<h3 id="Clang-交叉编译"><a href="#Clang-交叉编译" class="headerlink" title="Clang 交叉编译"></a>Clang 交叉编译</h3><p>前后端的 <code>target</code> 不同，可以在编译时添加 <code>--target</code> 选项来指定后端  <code>target</code> ，具体参看<a href="# Target Information">Target Information</a>。</p>
<h3 id="Clang-异常处理模型"><a href="#Clang-异常处理模型" class="headerlink" title="Clang 异常处理模型"></a>Clang 异常处理模型</h3><p>首先介绍一下 <code>MinGW-w64</code> 的异常模型的异同，可以参看<a href="https://gcc.gnu.org/wiki/WindowsGCCImprovements" target="_blank" rel="noopener">GCC Wiki</a> 和 <a href="https://stackoverflow.com/questions/15670169/what-is-difference-between-sjlj-vs-dwarf-vs-seh" target="_blank" rel="noopener">Stackoverflow</a>：</p>
<ul>
<li><code>SJLJ</code>（<code>setjmp</code> / <code>longjmp</code> ）： 支持 <code>32</code> 位和 <code>64</code> 位系统。传统的异常处理模型，性能较差即使没有抛出异常，也会导致较小的性能损失（严重异常代码的性能损失约为 <code>15%</code> ），但有时这种损失可能更大。</li>
<li><code>SEH</code> （<code>Structured Exception Handling</code> ）： 只支持  <code>64</code> 位系统。性能更加优异，当从不使用 <code>SEH</code> 的库z中抛出异常时，<code>SEH</code> 异常将导致非常糟糕的事情发生。</li>
<li><code>DWARF</code> ：只支持  <code>32</code> 位系统。需要使用 <code>DWARF-2</code>（或 <code>DWARF-3</code> ）调试信息。<code>DW2 EH</code> 会导致可执行文件稍微膨胀，因为大型的调用堆栈展开表必须包含在可执行文件中。</li>
</ul>
<p>一般情况下，<code>x86_64</code> 可选为 <code>seh</code> 和 <code>sjlj</code>，<code>i686</code> 为<code>dwarf</code> 和 <code>sjlj</code> 。你可以通过这个<a href="https://stackoverflow.com/questions/17967597/obtaining-current-gcc-exception-model" target="_blank" rel="noopener">回答</a>中的方法查看 <code>Clang</code> 和 <code>GCC</code> 的当前的异常处理模型，也可以阅读 <a href="http://llvm.org/docs/ExceptionHandling.html#itanium-abi-zero-cost-exception-handling" target="_blank" rel="noopener">Exceptions Handling in LLVM</a>。</p>
<p>普通 <code>Windows</code> 用户在使用 <code>Clang</code> 时可能更倾向于使用官网预编译的二进制版本直接安装，官网的编译版本通常是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Target: x86_64-pc-windows-msvc</span><br><span class="line">Thread model: posix</span><br></pre></td></tr></table></figure>
<p>预编译 <code>Clang</code> 默认的异常处理模型为 <code>seh</code> 。如果你使用 <code>MSVC</code> 作为后端，那么可能没有问题，因为 <code>MSVC</code> 同样使用 <code>seh</code> 。但如果你使用 <code>MinGW</code> 作为后端，就需要查看 <code>MinGW</code> 的异常处理模型是否与 <code>Clang</code> 默认的异常处理模型相同，如果不同， 可以添加 <code>-fdwarf-exceptions</code> 、 <code>-fsjlj-exceptions</code> 和 <code>-fseh-exceptions</code> 来指定异常处理模型，或者添加 <code>-fno-exceptions</code> 禁用异常机制（一般不建议）。</p>
<h3 id="Clang-编译流程"><a href="#Clang-编译流程" class="headerlink" title="Clang 编译流程"></a>Clang 编译流程</h3><p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/process1.jpg" alt="process1"><br><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/process2.png" alt="process2"></p>
<ol>
<li><code>Clang</code> 或 <code>Clang++</code> (以下以 <code>clang++</code> 为例说明，如有两者不同的特殊情况会专门指出）对待编译的源文件 <code>main.cpp</code>  进行预处理，例如将 <code>#include</code> 的文件复制到源文件中、展开宏定义、插入内联函数以及处理 <code>#if</code> 、<code>#endif</code> 、<code>#ifndef</code> 等命令。使用 <code>-E</code> 选项指定编译器只进行预处理。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ main.cpp -E -o main.i</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>Clang++</code> 将 <code>main.i</code> 编译为汇编代码文件。使用<code>-S</code> 选项指定编译器只进行预处理和编译。若添加上 <code>-emit-llvm</code> 选项，则会生成 <code>LLVM IR</code>（一种 <code>LLVM</code> 专用的中间表示，类似于汇编的可读的字节码）文件，否则会生成一般汇编代码文件。</p>
<p> <strong>注：</strong> <code>Clang</code> 的 <code>Release</code> 和 <code>Debug</code> 版生成的 <code>.ll</code> 文件略有不同，<code>Release</code> 版默认生成的 <code>.ll</code> 文件会丢弃变量的名字，你可以添加 <code>-fno-discard-value-names</code> 选项指定 <code>Clang</code> 保留原有的标签和标识符以增加可读性。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang++ main.cpp -S -o main.s</span><br><span class="line">clang++ main.cpp -S -emit-llvm -o main.ll</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Clang++</code> 将汇编代码文件进行汇编生成 <code>LLVM bitcode</code> （专指 <code>.bc</code> 文件）文件。使用<code>-c</code> 选项指定编译器只进行预处理、编译和汇编。若添加上 <code>-emit-llvm</code> 选项，则会生成 <code>LLVM bitcode</code> 文件，否则会生成 <code>.obj</code> 文件。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang++ main.cpp -c -o main.o</span><br><span class="line">clang++ main.cpp -c -emit-llvm -o main.bc</span><br></pre></td></tr></table></figure>
<p> <img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/compile.JPG" alt="compile"></p>
</li>
<li><p><code>Clang++</code> 将多个 <code>.obj</code> 文件或 <code>LLVM bitcode</code> 文件链接起来，形成一个完整的文件。使用 <code>-r</code> 选项指定编译器只进行符号链接，把多个 <code>.obj</code> 文件链接为一个总的 <code>.obj</code> 文件。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ main.o factorial.o -r -o linked.o</span><br></pre></td></tr></table></figure>
<p> <img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/link.JPG" alt="link"></p>
<p> <strong>注：</strong> </p>
<ol>
<li><p><code>libstdc++</code>  、<code>libc++</code>  和 <code>msvcrt</code> 都是 <code>C++</code> 标准库的一个实现。 <code>libstdc++</code> 是 <code>Linux</code> 上 <code>GCC</code> 的默认运行时库； <code>libc++</code> 是 <code>Mac OS</code> 上 <code>Clang</code> 的配套运行时库； <code>msvcrt</code> 是 <code>Windows</code> 上 <code>VS</code> 的默认运行时库。</p>
</li>
<li><p><code>C++</code> 会进行 <code>Name Mangling</code> ， <code>Name Mangling</code> 是将函数名和变量名编码为惟一的名称，以便链接器能够将语言中的名称区分开，以便实现重载。 <code>Name Mangling</code> 按照一定规则根据函数名和函数参数列表生成混淆后的函数名。</p>
<p> 使用以下命令可以得到混淆前的函数签名：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c++filt -n &lt;mangled-name&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<ol>
<li><p><code>Clang++</code> 将 <code>.obj</code> 文件编译生成可执行文件。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ linked.o -o main.exe</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li><p><code>clang</code> 和 <code>clang++</code> 只是前端的一个 <code>Driver</code> （驱动程序），<code>clang</code> 和 <code>clang++</code> 对源文件的处理本质上都是通过调用 <code>LLVM</code> 工具链实现的。<code>Clang</code> 的命令行用法参看<a href="https://clang.llvm.org/docs/CommandGuide/clang.html" target="_blank" rel="noopener">文档</a>。</p>
</li>
<li><p><code>clang</code> 和 <code>clang++</code> 在预处理、编译和汇编阶段是完全相同，<code>clang++</code> 本质上是 <code>clang</code> 的一个软连接，它通过后缀名来判断是 <code>C</code> 还是 <code>C++</code>，<code>-x &lt;language&gt;</code> 会指定文件语言类型 。不同的是 <code>clang++</code> 既可以链接 <code>C++</code> 标准库也可以链接 <code>C</code> 标准库，<code>clang</code> 只能链接 <code>C</code> 标准库。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clang++ test.c -o test.exe &#x2F;&#x2F; correct</span><br><span class="line">clang test.cpp -o test.exe &#x2F;&#x2F; error</span><br><span class="line">clang test.cpp -c -o test.o &#x2F;&#x2F; correct, because clang works same as clang++ during preprocess, compile and assemble steps</span><br><span class="line">clang test.cpp -stdc++ -o test.exe &#x2F;&#x2F; correct, clang complie successfully after specifing link library</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Clang-编译选项"><a href="#Clang-编译选项" class="headerlink" title="Clang 编译选项"></a>Clang 编译选项</h4><p><code>Clang</code> 兼容 <code>gcc</code> 的所有编译选项，同时<code>Clang</code> 有附带许多功能，我们可以通过添加编译选项来使用。</p>
<h4 id="m32-和-m64"><a href="#m32-和-m64" class="headerlink" title="-m32 和 -m64"></a><code>-m32</code> 和 <code>-m64</code></h4><p>使用 <code>32</code> 位的 <code>clang</code> 或 <code>gcc</code> 时默认生成 <code>32</code> 位的程序；使用 <code>64</code> 位的 <code>clang</code> 或 <code>gcc</code> 时默认生成 <code>64</code> 位的程序。</p>
<p>当 <code>Windows</code> 下使用 <code>64</code> 位的 <code>gcc</code> 编译 <code>32</code> 位的程序时，必须将对应的动态链接库地址加入到 <code>PATH</code> 环境变量（ <code>Linux</code> 下可以设置 <code>LD_LIBRARY_PATH</code> ）中，或者在编译时选择静态链接。</p>
<p><strong>注:</strong>  <code>clang</code> 对 <code>32</code> 位和 <code>64</code> 位交叉编译配置较为麻烦，远不如直接使用 <code>MinGW-w64</code> 。配置交叉编译的选项最好使用专门的构建工具（如 <code>CMake</code> , <code>Makefile</code> ），直接配置环境变量不仅费时费力，而且环境变量是全局的，对编译其他程序极不友好，很容易造成冲突。</p>
<h4 id="ftime-trace"><a href="#ftime-trace" class="headerlink" title="-ftime-trace"></a><code>-ftime-trace</code></h4><p><code>Clang 9.0.0</code>  增加了 <code>-ftime-trace</code> ， 这能够以友好的格式生成时间跟踪分析数据，对于开发人员更好地理解编译器将大部分时间花在何处以及其他需要改进的领域非常有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; clang++ test.cpp -ftime-trace -c -o test.o</span><br><span class="line">Time trace json-file dumped to test.json</span><br><span class="line">Use chrome:&#x2F;&#x2F;tracing or Speedscope App (https:&#x2F;&#x2F;www.speedscope.app) for flamegraph visualization</span><br></pre></td></tr></table></figure>
<p>在<a href="https://www.speedscope.app" target="_blank" rel="noopener">speedscope</a>中你可以看到以下的交互可视化图形：</p>
<p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/visualize1.png" alt="visualize1"></p>
<p><img src="/2020/07/19/Clang%E6%95%99%E7%A8%8B/visualize2.png" alt="visualize2"></p>
<p><a href="https://github.com/aras-p/ClangBuildAnalyzer" target="_blank" rel="noopener"><code>Clang Build Analyzer</code></a>工具有助于聚合来自多个编译的时间跟踪报告，并输出关于“什么花了最多的时间”的信息摘要。</p>
<h4 id="analyze"><a href="#analyze" class="headerlink" title="--analyze"></a><code>--analyze</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang --analyze -Xclang -analyzer-checker&#x3D;&quot;cplusplus&quot; test.cpp</span><br><span class="line">clang --analyze -Xanalyzer -analyzer-checker&#x3D;&quot;cplusplus&quot; test.cpp</span><br></pre></td></tr></table></figure>
<p><code>--analyze</code> 选项启动 <code>Clang</code> 的静态代码分析，能够检查代码中存在的错误与缺陷。 <code>Clang</code> 可以检查进行特定的检查（ <code>checker</code> ），<code>Clang</code> 内置的 <code>checker</code> 查看<a href="http://clang-analyzer.llvm.org/available_checks.html" target="_blank" rel="noopener">available_checks</a>。</p>
<h3 id="Clang-拓展"><a href="#Clang-拓展" class="headerlink" title="Clang 拓展"></a>Clang 拓展</h3><h4 id="clang-format"><a href="#clang-format" class="headerlink" title="clang-format"></a>clang-format</h4><p><code>clang-format</code> 是一个代码格式化工具，<code>clang-format</code> 内建了 <code>LLVM</code>，<code>Google</code>，<code>Chromium</code>， <code>Mozilla</code>， <code>WebKit</code> 五种格式，可以通过 <code>--style=</code> 指定，也可以使用 <code>--style=file</code> 从 <code>.clang-format</code> 文件中加载自定义代码格式配置（ <strong><code>clang-format</code> 的配置文件名必须是 <code>.clang-format</code></strong> ）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format --style&#x3D;LLVM -i main.cpp</span><br></pre></td></tr></table></figure>
<p><code>-i</code> 选项指定就地更改 <code>main.cpp</code>。</p>
<h4 id="clang-tidy"><a href="#clang-tidy" class="headerlink" title="clang-tidy"></a>clang-tidy</h4><p><code>clang-tidy</code> 是一个基于 <code>clang</code> 的 <code>C++</code> <code>linter</code>工具。它的目的是提供一个可扩展的框架，用于诊断和修复典型的编程错误，如样式违规、接口误用或可以通过静态分析推断出的 <code>bug</code> 。<code>clang-tidy</code> 是模块化的，提供了一个方便的接口来编写新的插件。<code>clang-tidy</code> 提供了许多 <code>check</code>，可以在 <code>-check=</code> 中指定一个或多个 <code>check</code>  （用 <code>,</code> 隔开）其他详细用法查看<a href="http://clang-analyzer.llvm.org" target="_blank" rel="noopener">官网</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-tidy -checks&#x3D;-*,clang-analyzer-*,-clang-analyzer-cplusplus* test.cpp --</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong></p>
<ol>
<li><code>Windows</code> 下使用要在命令行最后添加 <code>--</code> 。</li>
<li><code>Windows</code> 下 <code>clang-tidy</code> 的 <code>-check</code> 和 <code>-config</code> 选项组合在一起可能会出现问题，可以把所有选项都放在 <code>-config</code> 中。</li>
</ol>
<h4 id="clang-check"><a href="#clang-check" class="headerlink" title="clang-check"></a>clang-check</h4><p><code>clang-check</code> 与 <code>clang-tidy</code> 功能类似，在没有显示指定任何选项的情况下运行 <code>clang-check</code> 将运行 <code>-fsyntax-only</code> 模式（检查语法是否正确）。只有在指定 <code>-analyze</code> 时，才会执行静态分析工具，<strong>但不能同时指定 <code>-fsyntax-only</code> 和 <code>-analyze</code></strong>，<code>-check</code> 选项可以参考<a href="http://clang-analyzer.llvm.org/" target="_blank" rel="noopener">官网</a>。</p>
<p><code>clang-check</code> 还可以输出代码的 <code>AST</code> ，具体用法执行 <code>clang-check -help</code> 。</p>
<h3 id="LLVM-优化"><a href="#LLVM-优化" class="headerlink" title="LLVM 优化"></a>LLVM 优化</h3><p><code>clang</code> 一般只有在开启优化时才会内联函数，如果使用 <code>-fno-inline</code> 选项或 <code>-O0</code> 优化级别（默认优化级别），<code>GCC</code> 将不内联任何函数，可以使用 <code>-Winline</code> 选项来确定函数是否没有内联以及为什么没有内联。此时可以使用 <code>__attribute__</code> 机制。</p>
<p>在函数声明末尾 <code>;</code> 之前添加 <code>__attribute__((always_inline))</code> ，可以强制编译器内联函数（尽可能内联，必须满足内联函数要求）。</p>
<p><strong><code>C++</code> 中内联编译限制：</strong></p>
<ol>
<li>不能存在任何形式的循环语句。</li>
<li>不能存在过多的条件判断语句。</li>
<li>函数体不能过于庞大。</li>
<li>不能对函数进行取址操作。</li>
<li>内联函数声明必须在调用语句之前。</li>
</ol>
<h3 id="Clang-使用中遇到的问题"><a href="#Clang-使用中遇到的问题" class="headerlink" title="Clang 使用中遇到的问题"></a>Clang 使用中遇到的问题</h3><ol>
<li><p><code>MinGW-w64</code> 与 <code>float.h</code>  不兼容：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">G:\mingw64\x86_64-w64-mingw32\include\float.h:28:15: fatal error: &#39;float.h&#39; file not found</span><br><span class="line">#include_next &lt;float.h&gt;</span><br></pre></td></tr></table></figure>
<p> 查看 <a href="https://stackoverflow.com/questions/57166340/how-do-i-compile-code-using-clang-with-the-mingw-c-c-library-particular-issu" target="_blank" rel="noopener">‘float.h’ file not found-StackOverflow</a>。</p>
</li>
<li><p><code>member [...] in archive is not an object</code>  一般有2个原因：</p>
<ol>
<li>链接的对象或库文件位数不一致，例如 <code>x64</code> 和 <code>x86</code> 混合。</li>
<li>使用 <code>LTO</code> 时没有在编译和链接时都添加上 <code>flto</code> 。</li>
</ol>
</li>
<li><p>链接静态库时出现 <code>error: undefined reference to &#39;xxx&#39;</code> ，一般是由于缺少库文件或者链接顺序错误。被链接的库应该放在最后面。</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="_参考资料_"></a>_参考资料_</h2><p>[1] <a href="https://www.iteye.com/blog/user/rednaxelafx" target="_blank" rel="noopener">RednaxelaFX Blog</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/19/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李太吉">
      <meta itemprop="description" content="NPUer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李太吉的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/19/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-19 15:53:07" itemprop="dateCreated datePublished" datetime="2020-07-19T15:53:07+08:00">2020-07-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">李太吉</p>
  <div class="site-description" itemprop="description">NPUer</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李太吉</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
